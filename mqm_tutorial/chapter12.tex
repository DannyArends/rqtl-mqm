\documentclass[a4paper]{article}
\usepackage{Sweave}
\title { Chapter 12 - automated mqm modeling via analysis of deviance }
\author { Danny Arends, Pjotr Prins }
\begin {document}
\maketitle
\clearpage
\begin{Large} Missing data augmentation \end{Large}\\
First lest go into the augmentation of missing data, before we can use the mqm function, the data should be complete (no missing markers)
or we should augment it. The missing data augmentation routine mqmaugment() can do this for us, but we could also use multiple imputations
to estimate the missing markersgenotypes using fill.geno() from the r/qtl package. The mqmaugment() function can only handle 1 phenotype but this will be inproved upon soon. The parameters are:
$cross, pheno.col, maxaugind, augment\_aboveprob$ and verbose set this to TRUE to see what happens. $Maxind$ sets a maximum to the size of the dataset the default is usually good enough (60 is around 20 missing F2 markers per individual or 30 BC markers). The augmentation routine does an all or nothing filling of the missing markers. The individual is expanded untill the $augment\_aboveprob$: Augment genotypes that are above a probability of occurring (ignore lower probabilities). Setting this value too high may result in dropping individuals entirely.
Lets start by simulating a dataset with some missing markers (2\%) and discuss howto use the augmentation routine:
\\
\begin{Schunk}
\begin{Sinput}
> library(qtl)
> data(map10)
> mycross <- sim.cross(map10, type = "f2", n.ind = 100, missing.prob = 0.02)
> plot.geno(mycross)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-001}
\begin{Schunk}
\begin{Sinput}
> augmentedcross <- mqmaugment(mycross, augment_aboveprob = 1)
\end{Sinput}
\begin{Soutput}
Starting C-part of the data augmentation routine
F2 cross
Convert codes R/qtl -> MQM
Filling the chromosome matrix
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
\end{Soutput}
\begin{Sinput}
> plot.geno(augmentedcross)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-002}
\\
When we use a larger $augment\_aboveprob$ (so more unlikely genotypes are also consideren we see the dataset expanding in size.
This expanded dataset can only be analysed correctly with the mqm routine, because scanone will treat duplicated individuals
as new individuals (that improve power). MQM does not do this it treats duplicated individuals together as a single entity.
\\
\begin{Schunk}
\begin{Sinput}
> augmentedcross <- mqmaugment(mycross, augment_aboveprob = 10)
\end{Sinput}
\begin{Soutput}
Starting C-part of the data augmentation routine
F2 cross
Convert codes R/qtl -> MQM
Filling the chromosome matrix
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
\end{Soutput}
\begin{Sinput}
> plot.geno(augmentedcross)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-003}
\clearpage
\begin{Large} MQM modeling and mapping \end{Large}\\
We start bij analyzing the hyperset data this can be loaded into memory by using $data(hyper)$
\texttt{qtl.mqm} help page into a \LaTeX{} document
\\
\begin{Schunk}
\begin{Sinput}
> data(hyper)
> colors <- c("Black", "Green")
> lines <- c(2, 1)
> h_no_missing <- mqmaugment(hyper, augment_aboveprob = 1)
\end{Sinput}
\begin{Soutput}
Starting C-part of the data augmentation routine
Back cross (BC)
Convert codes R/qtl -> MQM
Filling the chromosome matrix
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
\end{Soutput}
\begin{Sinput}
> result <- mqm(h_no_missing)
\end{Sinput}
\begin{Soutput}
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
\end{Soutput}
\begin{Sinput}
> result_compare <- scanone(h_no_missing)
\end{Sinput}
\end{Schunk}
Output of the QTLscan:
\\
\begin{Schunk}
\begin{Sinput}
> plot(result, result_compare, col = colors, lwd = lines)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-005}
\\
We see 1 to 1 correspondance between the scanone function and the mqm routine when using no paramters
We can now use two approaches:
1) Start building a model by hand or,
2) Use unsupervised backward selection on a large number of markers
We will start by first building the model by hand. We see the big peek on chromosome 4,
so lets account for that by setting a cofactor at the marker nearest to the peek on chromosome 4
\\
\begin{Schunk}
\begin{Sinput}
> summary(result)
\end{Sinput}
\begin{Soutput}
       chr pos (Cm) QTL bp  Info QTL*INFO
C1L80    1       80  3.534 0.884    3.123
C2L60    2       60  1.448 0.902    1.306
C3L25    3       25  0.612 0.909    0.557
C4L30    4       30  7.059 0.923    6.518
C5L70    5       70  1.428 0.932    1.331
C6L25    6       25  1.755 0.949    1.665
C7L25    7       25  0.361 0.939    0.339
C8L65    8       65  1.674 0.904    1.513
C9L70    9       70  1.464 0.928    1.359
C10L10  10       10  0.134 0.907    0.121
C11L40  11       40  0.703 0.904    0.636
C12L0   12        0  0.442 0.928    0.410
C13L0   13        0  0.344 0.845    0.291
C14L10  14       10  0.324 0.937    0.304
C15L20  15       20  2.204 0.924    2.037
C16L50  16       50  0.945 0.937    0.885
C17L55  17       55  0.136 0.862    0.117
C18L10  18       10  1.369 0.888    1.216
C19L0   19        0  0.700 0.950    0.665
C20L40  20       40  2.044 0.910    1.860
\end{Soutput}
\begin{Sinput}
> find.marker(h_no_missing, 4, 30)
\end{Sinput}
\begin{Soutput}
[1] "D4Mit164"
\end{Soutput}
\begin{Sinput}
> toset <- which.marker(h_no_missing, "D4Mit164")
\end{Sinput}
\begin{Soutput}
Marker D4Mit164 is number 46 
\end{Soutput}
\begin{Sinput}
> cofactorlist <- mqmcofactors(h_no_missing, toset)
> result <- mqm(h_no_missing, cofactorlist)
\end{Sinput}
\begin{Soutput}
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
\end{Soutput}
\begin{Sinput}
> plot(result, result_compare, col = colors, lwd = lines)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-006}
\\
After setting a cofactor on chromosome 4, the second peek on chromosome 1 becomes higher, so lets try adding that one too
\\
\begin{Schunk}
\begin{Sinput}
> summary(result)
\end{Sinput}
\begin{Soutput}
       chr pos (Cm) QTL bp  Info QTL*INFO
C1L70    1       70 5.2241 0.946   4.9398
C2L60    2       60 1.3684 0.901   1.2333
C3L25    3       25 0.8108 0.909   0.7369
C4L30    4       30 7.9020 0.924   7.3047
C5L70    5       70 1.4894 0.932   1.3887
C6L25    6       25 1.5220 0.949   1.4441
C7L25    7       25 0.2024 0.939   0.1902
C8L60    8       60 1.3239 0.940   1.2447
C9L65    9       65 1.2612 0.896   1.1302
C10L15  10       15 0.0940 0.947   0.0890
C11L40  11       40 0.8636 0.904   0.7804
C12L0   12        0 0.3386 0.928   0.3143
C13L0   13        0 0.1989 0.845   0.1680
C14L10  14       10 0.3804 0.937   0.3566
C15L20  15       20 2.4776 0.924   2.2887
C16L50  16       50 0.6714 0.938   0.6295
C17L5   17        5 0.0825 0.944   0.0779
C18L10  18       10 0.8184 0.885   0.7241
C19L45  19       45 0.4146 0.882   0.3656
C20L40  20       40 1.7845 0.911   1.6255
\end{Soutput}
\begin{Sinput}
> toset <- c(toset, which.marker(h_no_missing, find.marker(h_no_missing, 
+     1, 70)))
\end{Sinput}
\begin{Soutput}
Marker D1Mit218 is number 12 
\end{Soutput}
\begin{Sinput}
> cofactorlist <- mqmcofactors(h_no_missing, toset)
> result <- mqm(h_no_missing, cofactorlist)
\end{Sinput}
\begin{Soutput}
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
\end{Soutput}
\end{Schunk}
That marker is also informative enough to be included into the model, we can continue this process of adding
cofactors untill there are no more informative markers that can be included
This could be very time consuming in the case of many QTLs underlying your trait,
we can also explore our data using strategy 2 and set cofactors every other marker. The algorithm will analyse
all the markers and if found to be non explainatory drop them from the model. After
selection it will scan the chromosome using the model created from the cofactors
Using the plot=T we also get a graphical overview of the model
\\
\begin{Schunk}
\begin{Sinput}
> plot(result, result_compare, col = colors, lwd = lines)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-008}
Automatic scanning using cofactors at each 5th marker is done by using the $mqmcofactorsEach()$ function\\
\begin{Schunk}
\begin{Sinput}
> cofactorlist <- mqmcofactorsEach(h_no_missing, 5)
> result <- mqm(h_no_missing, cofactorlist, plot = T)
\end{Sinput}
\begin{Soutput}
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
\end{Soutput}
\end{Schunk}
\includegraphics{chapter12-009}
Comparing back to the scanone:
\\
\begin{Schunk}
\begin{Sinput}
> plot(result, result_compare, col = colors, lwd = lines)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-010}
\\
This leads to a lot of hits and multiple hits on each chromosome, because some cofactors are too close to eachother
However we see that according to mqm chromosomes 1,2,4,5,6 and (15?) are implicated using this method
This is a fairly extensive model, and lowering the significance level from 0.02 to 0.002 could yield a more comprehensable model
\\
\begin{Schunk}
\begin{Sinput}
> result <- mqm(h_no_missing, cofactorlist, alfa = 0.002, plot = T)
\end{Sinput}
\begin{Soutput}
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
\end{Soutput}
\end{Schunk}
\includegraphics{chapter12-011}
\clearpage
\begin{Large} MQM effects \end{Large}\\
This model implicates chromosomes 1,2,4 and 5. If we want to investigate the effects of the peek we can use r/qtl standard plotting tools
to estimate Main effects and epistatic effects. The follwoing code will plot those 2 plots on markers D1M102 (main effect) and the interaction between this marker and D5Mit213 to show epistase or additive effect.
\\
\begin{Schunk}
\begin{Sinput}
> plot.pxg(h_no_missing, marker = "D1Mit102")
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-012}
\\
Possible interaction on chromosome 1
\\
\begin{Schunk}
\begin{Sinput}
> effectplot(h_no_missing, mname1 = "D1Mit19", mname2 = "D1Mit102")
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-013}
\\
Possible interaction between chromosome 1 and 5
\\
\begin{Schunk}
\begin{Sinput}
> effectplot(h_no_missing, mname1 = "D1Mit102", mname2 = "D5Mit213")
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-014}
\\
We can see that there are (no) interactions between the 2 markers D1Mit102 and D5Mit213. This is because both lines are parallel thus there is no effect (on D5Mit213) from having a certain genotype at marker D1Mit102 for eaxample. If we would see two lines non-parallel this would indicate an epistatic effect at that marker. 
\clearpage
\begin{Large} Significance and Thresholds \end{Large}\\
To estimate significance of the Peeks (and perhaps exclude some more markers) we can use permutation.
In small sets with a limited amount of traits we use bootstrap(). On large GWAS sets (gene expression etc) we use the FDRpermutation to estimate FDR across the entire set at certain lod cutoffs (We do 10 because of speed of generating the document this should be 1000 with $b.size=25 or 50$).
\\
\begin{Schunk}
\begin{Sinput}
> library(snow)
> results <- bootstrap(h_no_missing, mqm, cofactors = cofactorlist, 
+     plot = T, verbose = T, n.clusters = 2, n.run = 10, b.size = 10)
\end{Sinput}
\begin{Soutput}
------------------------------------------------------------------
Starting bootstrap analysis
Number of bootstrapping runs: 10 
Batchsize: 10  & n.clusters: 2 
------------------------------------------------------------------
INFO: Received a valid cross file type: bc .
INFO: Shuffleling traits between individuals.
------------------------------------------------------------------
INFO: Starting analysis of trait ( 1 / 1 )
------------------------------------------------------------------
Back cross (BC)
Convert codes R/qtl -> MQM
Receiving the chromosome matrix from R
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Initialize Frun and informationcontent to 0.0
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
After dropping of uninformative cofactors
Calculating relative genomepositions of the markers
Estimating recombinant frequencies
Analysis of data finished
------------------------------------------------------------------
INFO: Done with the analysis of trait ( 1 / 1 )
INFO: Calculation of trait 1 took: 7.55  seconds
------------------------------------------------------------------
INFO: Library snow found using  2  Cores/CPU's/PC's for calculation.
------------------------------------------------------------------
INFO: Starting with batch 1 / 1 
------------------------------------------------------------------
INFO: Done with batch 1 / 1 
INFO: Calculation of batch 1 took: 38.32 seconds
INFO: Elapsed time: 0 : 0 : 38 (Hour:Min:Sec)
INFO: Average time per batch: 38.32  per trait: 3 seconds
INFO: Estimated time left: 0 : 0 : 0 (Hour:Min:Sec)
------------------------------------------------------------------
INFO: Done with MQM bootstrap analysis
------------------------------------------------------------------
INFO: Elapsed time: 0 : 0 : 46 (Hour:Min:Sec)
INFO: Average time per trait: 4.17 seconds
------------------------------------------------------------------
\end{Soutput}
\end{Schunk}
\includegraphics{chapter12-015}
\\
This shows that only QTL's above 2.5 LOD score can be trusted (at $alpha=0.05 (green)$ or $alpha=0.10 (blue)$).
\begin{Large} Multiple traits using MQM \end{Large}\\
We can also use MQM unsupervised to analyse multiple traits simultaniously. We show using no-cofactors first, and then using cofactors to do backward elimination. we see improvement int the noise to signal ratio in the in the heatmap.
\begin{Schunk}
\begin{Sinput}
> data(multitrait)
> multifilled <- fill.geno(multitrait)
> resall <- mqmall(multifilled, n.clusters = 2, verbose = T)
\end{Sinput}
\begin{Soutput}
------------------------------------------------------------------
Starting R/QTL multitrait analysis
Number of phenotypes: 24 
Batchsize: 10  & n.clusters: 2 
------------------------------------------------------------------
INFO: Library snow found using  2  Cores/CPU's/PC's for calculation.
------------------------------------------------------------------
INFO: Starting with batch 1 / 3 
------------------------------------------------------------------
INFO: Done with batch 1 / 3 
INFO: Calculation of batch 1 took: 7.47 seconds
INFO: Elapsed time: 0 : 0 : 7 (Hour:Min:Sec)
INFO: Average time per batch: 7.47  per trait: 0 seconds
INFO: Estimated time left: 0 : 0 : 15 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Starting with batch 2 / 3 
------------------------------------------------------------------
INFO: Done with batch 2 / 3 
INFO: Calculation of batch 2 took: 6.78 seconds
INFO: Elapsed time: 0 : 0 : 14 (Hour:Min:Sec)
INFO: Average time per batch: 7.125  per trait: 0 seconds
INFO: Estimated time left: 0 : 0 : 7 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Starting with batch 3 / 3 
------------------------------------------------------------------
INFO: Done with batch 3 / 3 
INFO: Calculation of batch 3 took: 5.03 seconds
INFO: Elapsed time: 0 : 0 : 19 (Hour:Min:Sec)
INFO: Average time per batch: 6.427  per trait: 0 seconds
INFO: Estimated time left: 0 : 0 : 0 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Elapsed time: 0 : 0 : 24 (Hour:Min:Sec)
INFO: Average time per trait: 1.013 seconds
------------------------------------------------------------------
\end{Soutput}
\begin{Sinput}
> mqmplotall(resall, "I")
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-016}
\begin{Schunk}
\begin{Sinput}
> cofactorlist <- mqmcofactorsEach(multifilled, 3)
> resall <- mqmall(multifilled, cofactors = cofactorlist, n.clusters = 2, 
+     verbose = T)
\end{Sinput}
\begin{Soutput}
------------------------------------------------------------------
Starting R/QTL multitrait analysis
Number of phenotypes: 24 
Batchsize: 10  & n.clusters: 2 
------------------------------------------------------------------
INFO: Library snow found using  2  Cores/CPU's/PC's for calculation.
------------------------------------------------------------------
INFO: Starting with batch 1 / 3 
------------------------------------------------------------------
INFO: Done with batch 1 / 3 
INFO: Calculation of batch 1 took: 14.25 seconds
INFO: Elapsed time: 0 : 0 : 14 (Hour:Min:Sec)
INFO: Average time per batch: 14.25  per trait: 1 seconds
INFO: Estimated time left: 0 : 0 : 28 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Starting with batch 2 / 3 
------------------------------------------------------------------
INFO: Done with batch 2 / 3 
INFO: Calculation of batch 2 took: 14.39 seconds
INFO: Elapsed time: 0 : 0 : 29 (Hour:Min:Sec)
INFO: Average time per batch: 14.32  per trait: 1 seconds
INFO: Estimated time left: 0 : 0 : 14 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Starting with batch 3 / 3 
------------------------------------------------------------------
INFO: Done with batch 3 / 3 
INFO: Calculation of batch 3 took: 7.92 seconds
INFO: Elapsed time: 0 : 0 : 37 (Hour:Min:Sec)
INFO: Average time per batch: 12.187  per trait: 1 seconds
INFO: Estimated time left: 0 : 0 : 0 (Hour:Min:Sec)
------------------------------------------------------------------
------------------------------------------------------------------
INFO: Elapsed time: 0 : 0 : 44 (Hour:Min:Sec)
INFO: Average time per trait: 1.853 seconds
------------------------------------------------------------------
\end{Soutput}
\begin{Sinput}
> mqmplotall(resall, "I")
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-017}
\begin{Schunk}
\begin{Sinput}
> mqmplotnice(resall, legendloc = 1)
\end{Sinput}
\end{Schunk}
\includegraphics{chapter12-018}
\end{document}
