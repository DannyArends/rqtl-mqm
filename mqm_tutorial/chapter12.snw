\documentclass[a4paper]{article}
\usepackage{Sweave}
\title { Chapter 12 - automated mqm modeling via analysis of deviance }
\author { Danny Arends, Pjotr Prins }
\begin {document}
\maketitle
First lest go into the augmentation of missing data, before we can use the mqm function, the data should be complete (no missing markers)
or we should augment it. The missing data augmentation routine mqmaugment() can do this for us, but we could also use multiple imputations
to estimate the missing markersgenotypes using fill.geno() from the r/qtl package. The mqmaugment() function can only handle 1 phenotype but this will be inproved upon soon. The parameters  are:
cross, pheno.col = 1 , maxaugind = 60, augment_aboveprob = 1 and verbose set this to TRUE to see what happens. Maxind sets a maximum to the size of the dataset the default is usually good enough (60 is ~ 20 missing F2 markers per individual or 30 BC markers). The augmentation routine does an all or nothing filling of the missing markers. The individual is expanded untill the augment_aboveprob: Augment genotypes that are above a probability of occurring (ignore lower probabilities). Setting this value too high may result in dropping individuals entirely.
Lets start by simulating a dataset with some missing markers and discuss howto use the augmentation routine:
<<fig=TRUE>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.01)
plot.geno(mycross)
augmentedcross <- mqmaugment(mycross, augment_aboveprob=1)
plot.geno(augmentedcross)
augmentedcross <- mqmaugment(mycross, augment_aboveprob=10)
plot.geno(augmentedcross)
@
We start bij analyzing the hyperset data
\texttt{qtl.mqm} help page into a \LaTeX{} document :
<<>>=
data(hyper)
colors <- c("Black","Green")
lines <- c(2,1)
h_no_missing <- mqmaugment(hyper, augment_aboveprob=1)
result <- mqm(h_no_missing)
result_compare <- scanone(h_no_missing)
@
Output of the QTLscan:
<<fig =TRUE , echo =FALSE >>=
plot(result, result_compare, col=colors, lwd=lines)
@
We see 1 to 1 correspondance between the scanone function and the mqm routine when using no paramters
We can now use two approaches:
1) Start building a model by hand or,
2) Use unsupervised backward selection on a large number of markers
We will start by first building the model by hand. We see the big peek on chromosome 4,
so lets account for that by setting a cofactor at the marker nearest to the peek on chromosome 4
<<fig =TRUE>>=
summary(result)
find.marker(h_no_missing,4,30)
toset <- which.marker(h_no_missing,"D4Mit164")
cofactorlist <- mqmcofactors(h_no_missing,toset)
#scan again
result <- mqm(h_no_missing, cofactorlist)
plot(result, result_compare, col=colors, lwd=lines)
@
After setting a cofactor on chromosome 4, the second peek on chromosome 1 becomes higher, so lets try adding that one too
<<>>=
summary(result)
#we can combine find marker and which.marker commands and expand our toset variable
toset <- c(toset,which.marker(h_no_missing,find.marker(h_no_missing,1,70)))
cofactorlist <- mqmcofactors(h_no_missing,toset)
#scan again
result <- mqm(h_no_missing, cofactorlist)
@
That marker is also informative enough to be included into the model, we can continue this process of adding
cofactors untill there are no more informative markers that can be included
This could be very time consuming in the case of many QTLs underlying your trait,
we can also explore our data using strategy 2 and set cofactors every other marker. The algorithm will analyse
all the markers and if found to be non explainatory drop them from the model. After
selection it will scan the chromosome using the model created from the cofactors
Using the plot=T we also get a graphical overview of the model
<<fig =TRUE>>=
plot(result, result_compare, col=colors, lwd=lines)
cofactorlist <- mqmcofactorsEach(h_no_missing,2)
result <- mqm(h_no_missing, cofactorlist, plot=T)
#We could plot also back against the scanone function.
plot(result, result_compare, col=colors, lwd=lines)
@
This leads to a lot of hits and multiple hits on each chromosome, because some cofactors are too close to eachother
However we see that according to mqm chromosomes 1,2,4,5,6,7,11 and 14 are implicated using this method
This is a fairly extensive model, and lowering the significance level from 0.02 to 0.002 could yield a more comprehensable model
<<fig =TRUE>>=
cofactorlist <- mqmcofactorsEach(h_no_missing,2)
result <- mqm(h_no_missing, cofactorlist, alfa=0.002, plot=T)
@
This model implicates chromosomes 1,2,4 and 5. If we want to investigate the effects of the peek we can use r/qtl standard plotting tools
to estimate Main effects and epistatic effects. The follwoing code will plot those 2 plots.
<<fig =TRUE>>=
plot.pxg(h_no_missing,marker="D1Mit132")
effectplot(h_no_missing, mname1="D1Mit132", mname2="D5Mit169")
@
We can see that there are (no) interactions between the 2 markers D1Mit132 and D5Mit168. This is because both lines are parallel thus there is no effect (on D5Mit168) from having a certain genotype at marker D1Mit168 for eaxample. If we would see two lines non-parallel this would indicate an epistatic effect at that marker. To estimate significance of the Peeks (and perhaps exclude some more markers) we can use permutation.
In small sets with a limited amount of traits we use bootstrap(). On large GWAS sets (gene expression etc) we use the FDRpermutation to estimate FDR across the entire set at certain lod cutoffs.
<<fig =TRUE>>=
results <- bootstrap(h_no_missing,mqm,cofactors=cofactorlist,plot=T,n.run=10,b.size=5)
@
This shows that only QTL's above XX LOD score can be trusted (at an alpha=0.05) level.
\end{document}
