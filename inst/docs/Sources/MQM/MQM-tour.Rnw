\documentclass[11pt]{article}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{23.5cm}
\setlength{\textwidth}{17.0cm}
\setlength{\oddsidemargin}{.025in}
\setlength{\evensidemargin}{.025in}
\setlength{\textwidth}{6.25in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{float}
\usepackage{Sweave}
\usepackage{url}

\newcommand{\mqm}{\emph{MQM}}
\newcommand{\MQM}{\mqm}
\newcommand{\qtl}{QTL}
\newcommand{\QTL}{\qtl}
\newcommand{\lod}{LOD}
\newcommand{\cM}{cM}
\newcommand{\rqtl}{\emph{R/qtl}}
\newcommand{\cim}{\emph{CIM}}
\newcommand{\At}{\emph{Arabidopsis thaliana}}
\newcommand{\FIXME}{({\bf FIXME!})}
\newcommand{\CHECK}{({\bf CHECK!})}
\newcommand{\NOTE}[1]{({\tt NOTE: #1 })}
\newcommand{\intro}[1]{\vspace{0.15in}#1:}
\newcommand{\code}{\texttt}

\newcommand{\Atintro}{\At\ RIL mQTL dataset (multitrait) with 24 metabolites as phenotypes \cite{Keurentjes2006}}
\newcommand{\Atintrocolors}{\Atintro\ comparing \mqm\ (black) and
single \qtl\ mapping with \code{scanone} (green, dashed)}

\title { Tutorial - Multiple QTL Model (MQM) Analysis }
\author { Danny Arends, Pjotr Prins, Karl W. Broman and Ritsert Jansen }
\begin {document}
\maketitle
\clearpage

\setkeys{Gin}{width=6.25in} %% <- change width of figures

\section{Introduction}

\input{mqm/description.txt}

\vspace{0.3in}

\input{mqm/advantages_latex.txt}

\input{mqm/limitations.txt}

Despite these limitations, \mqm\footnote{MQM should not be confused with
composite interval mapping (CIM) \cite{CIMa,CIMb}.  The advantage of MQM
over CIM is reduction of type I error (a QTL is indicated at a location where there
is no QTL present) and type II error (a QTL is not detected) for QTL detection
\cite{jansen94b}.} is a valuable addition to the \qtl\ mapper's toolbox. It
is able to deal with QTL in coupling phase and QTL in repulsion phase. \mqm\
handles missing data and has higher precision than other methods.  R/qtl's
\mqm\ is faster than other implementations and scales on multi-CPU systems and
computer clusters.  In this tutorial we will show you how to use \mqm\ for
\qtl\ mapping. 

\mqm\ is an integral part of the free \rqtl\
package \cite{rqtlbook,broman09,broman03} for the R statistical
language\footnote{We assume the reader knows how to load his data into R using
the R/qtl \code{read.cross} function; see also the R/qtl tutorials \cite{broman09}
and book \cite{rqtlbook}.}. 

\section{A quick overview of \mqm}

These are the typical steps in an \mqm\ \qtl\ analysis:

\begin{itemize}
\item Load data into R
\item Fill in missing data, using either \code{mqmaugmentdata} or \code{fill.geno}
\item Unsupervised backward elimination to analyse \emph{cofactors}, using \code{mqmscan}
\item Optionally select \emph{cofactors\/} at markers that are thought to influence \qtl\ at, or near, the location
\item Permutation or simulation analysis to get estimates of significance, using \code{mqmpermutation}
\end{itemize}

Using maximum likelihood (ML), or restricted maximum likelihood (REML), the
algorithm employs a backward elimination strategy to identify \qtl\ underlying
the trait. The algorithm passes through the following stages:

\begin{itemize}
\item Calculation of relative marker positions and detection of linkage groups
\item Optional (re-)estimation of genetic map and/or recombination frequencies
\item Likelihood-based estimation of the full model using all cofactors
\item Backward elimination of cofactors, followed by a
      genome scan for \qtl
\item If there are no \emph{cofactors\/} defined, perform a
      genome scan testing each genetic location independently
\end{itemize}

The results created during the genome scan and the \qtl\ model are
returned as an (\mqm\ extended) R/qtl \code{scanone} object. Several special
plotting routines are available for \mqm\ results.

\section{Data augmentation}
\label{augmentation}

Most datasets are incomplete. That is, genotype
information is missing, or can have multiple plausible values. \mqm\
automatically expands the
dataset by adding all potential variants and attaches a probability to each.  For
example, information is missing (unknown) at a marker location for one
individual. Based on the values of the neighbouring markers, and the
(estimated) recombination rate, a probability is attached to all possible
genotypes.  With \mqm\ all possible genotypes with a probability above
\code{minprob} are considered.  

When encountering a missing marker genotype (possible genotypes {\bf A} and {\bf B} in a
RIL), all possible genotypes at the missing location are created.  Thus at
the missing location two `individuals' are created in the augmentation step,
one with genotype {\bf A}, and one with genotype {\bf B}. A probability is
attached to both augmented individuals.  The combined probability of all
missing marker locations tells whether a genotype is likely, or unlikely,
allowing for weighted analysis later.

To see an example of missing data with an F$_2$ intercross, we can
visualize the genotypes of the individuals using \code{geno.image}. In
Figure~\ref{missing data} there are 2\% missing values in white. The
other colors are genotypes at a certain position, for a certain
individual. Simulate an F$_2$ dataset with 2\% missing genotypes as
follows:

\intro{Simulate a dataset with missing data}
% set seed so that everything comes out exactly the same
<<setseed,echo=FALSE>>= 
set.seed(19696527)
@ 
<<>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.02)
@

and plot the genotype data using \code{geno.image} (Figure~\ref{missing data}):


<<missingdata,eval=FALSE>>=
geno.image(mycross)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<missingdata>>
@
\caption{Genotype data for a simulated F$_2$ intercross generated with \code{sim.cross}, with 100
  individuals and 2\% missing data.  White pixels indicate missing genotypes.\label{missing data}}
\end{figure}

Before going to the next step (the \qtl\ genome scan), the data has to be
completed (i.e. no more missing data).  There are two possibilities: (1) 
the \mqm\ data augmentation routine \code{mqmaugment} or (2) the imputation
function \code{fill.geno}. As described above, augmentation tries to analyse
all possible genotypes of interest by leaving them in the solution space. In contrast,
the imputation method \emph{selects} the most likely genotype, and uses that
single individual for further analysis. 

The downside of augmentation is that the addition of many possible genotypes
can exceed available computer memory.  Currently, augmentation moves an
individual to a second augmentation round. In the second augmentation round the
user can specify what needs to be done with these individuals: (1) Only use the
most likely ones, (2) use multiple imputation for the original genotype or (3)
remove the original genotype/individual from the analysis.  Note you can opt to
use \code{fill.geno}'s imputation method, instead of augmentation, when too
many individuals are omitted, because of missing data.

The function \code{mqmaugment} is specific to \mqm\ and the recommended
procedure\footnote{Note that after augmentation the resulting object is
no longer suitable for the use with other R/qtl mapping functions, like \code{scanone} and \cim, because of the
duplication or potential omission of many individuals.}.  
In this tutorial we focus on \mqm's augmentation. The function \code{mqmaugment} fills in
missing genotypes for us. For each missing genotype data, at a marker, it fills
in all possible genotypes and calculates the probability. When the total
probability is higher than the \code{minprob} parameter the \emph{augmented}
individual is stored in the new cross object, ready for QTL mapping.

The important parameters are: \code{cross}, \code{pheno.col}, \code{maxaugind}, \code{minprob} and
\code{verbose} (see also the \code{mqmaugment} help page). \code{maxaugind} sets the
maximum number of \emph{augmented} genotypes per individual in a dataset. The
default of 82 allows six missing markers per individual in a BC, and four in an
F$_2$. As a result the user has to increase the
\code{maxaugind} parameter when there are more missing markers. 

The \code{minprob} parameter sets the minimum probability of a genotype for
inclusion in the augmented dataset. This genotype probability is calculated for
every marker \emph{relative} to the most likely individual.  Note that setting
this value too low may result in moving a lot of individuals to the second
augmentation round as the maximum of augmented individuals (the parameter \code{maxaugind}) is quickly reached.
Increasing \code{minprob} (towards a value of 1.0) can keep individuals with more
missing data inside the first augmentation round; a good rule of thumb may be
to set \code{minprob} to the percentage of data missing. A value of
\code{minprob=1.0} makes augmentation behave similar to \code{fill.geno}'s
imputation method, though with different resulting genotypes.  Use
\code{verbose=TRUE} to get more feedback on the augmentation routine and to
check how many individuals are moved to the stages of imputation / mostLikely /
removal\footnote{Augmentation is not always suitable with a lot of missing
data, like in the case of selective genotyped datasets (for example the mouse \code{hyper}
dataset that comes with R/qtl); these will always be handled with \code{minprob=1.0}
(a warning will be issued).}

To start with an example, first run \code{mqmaugment} with \code{minprob=1.0}
(Figure~\ref{augment1}):

\intro{Plot augmented data using \code{geno.image}}
<<>>=
# displays warning because MQM ignores the X chromosome in an F2
augmentedcross <- mqmaugment(mycross, minprob=1.0)
@
Plot the genotype data as follows:
<<augment1,eval=FALSE>>=
geno.image(augmentedcross)
@ 
\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<augment1>>
@
\caption{Genotypes, as visualized with \code{geno.image}, of 100 filled individuals
(\code{mqmaugment} with \code{minprob=1.0}. With missing data only a `most
likely' individual is used and no real expansion of the dataset takes place,
with similar results as \code{fill.geno}'s imputation method).\label{augment1}}
\end{figure}

With a lower \code{minprob}, more \emph{unlikely\/} genotypes are kept, and the
resulting \emph{augmented} dataset will be larger. The (weighted) augmented
individuals with all possible genotypes theoretically leads to more accurate
mapping when dealing with missing values \cite{jansen93}\footnote{Note again that
the augmented dataset can only be used with pure \mqm\ functions.  \mqm\ functions
recognise expanded individuals as single entities.  Other R/qtl functions, like
\code{scanone}, assume the augmented individuals are \emph{real} individuals.}.
Try augmentation with \code{minprob=0.1} (Figure~\ref{augment2}):
<<>>=
augmentedcross <- mqmaugment(mycross, minprob=0.1)
@ 

\intro{Plot the genotype data}

<<augment2,eval=FALSE>>=
geno.image(augmentedcross)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<augment2>>
@
\caption{Genotypes, as visualized with \code{geno.image} of the \emph{augmented} 
genotypes of 100 individuals. There are a total of \Sexpr{nind(augmentedcross)} 
`expanded' individuals in this plot, because \mqm\ fills in missing markers with 
all likely genotypes (an average expansion of \Sexpr{round(nind(augmentedcross)/nind(mycross),1)} per
individual).\label{augment2}}
\end{figure}

\label{multitrait}
A dataset (\code{multitrait}), which contains 24 metabolite
traits from a RIL population of \At is now distributed with
R/qtl (load the data with \code{data(multitrait)}).  This is part of the \At\ RIL selfing experiment
with Landsberg erecta (Ler) and Cape Verde Islands (Cvi) with 162 individuals
scored (with errors at) 117 markers \cite{Koornneef1998}. The experiment
concerned empirical untargeted metabolomics using liquid chromatography time of
flight mass spectrometry (LC-QTOF MS). This uncovered many qualitative and
quantitative differences in metabolite accumulation between \At\ accessions
\cite{Keurentjes2006}.

\intro{Simulate missing data by removing some genotype data (5\%, 10\%
  and 80\%) from the cross object}

<<augment3>>=
data(multitrait)
msim5 <- simulateMissingData(multitrait,5)
msim10 <- simulateMissingData(multitrait,10)
msim80 <- simulateMissingData(multitrait,80)
@

Next use augmentation to fill in the missing genotypes; with more missing data
increase the \code{minprob} parameter.  When the \code{minprob} parameter is
set too low it is possible that an individual cannot be augmented, 
and is moved to the second round of augmentation (see the description above).

<<augment4>>=
maug5 <- mqmaugment(msim5)
maug10 <- mqmaugment(msim10,minprob=0.25)
maug80 <- mqmaugment(msim80,minprob=0.80)
@

If, however, we use the multitrait dataset with 10 \% missing data and set \code{minprob} at a lower value (e.g. 0.001),
then some individuals are moved to the second round and missing data is either filled using the most likely genotype 
or using imputation. We can also choose to drop the individuals entirely from the rest of the analysis; however, this is
not advisable because usable information is lost.

<<augmentMinProb>>=
maug10minprob <- mqmaugment(msim10,minprob=0.001,verbose=TRUE)
maug10minprobImpute <- mqmaugment(msim10,minprob=0.001,unaugmentable="impute",verbose=TRUE)
# nind(maug)
nind(maug10minprob)
nind(maug10minprobImpute)
@

After augmentation check how many individuals are expanded.  Next
scan for QTL inside the cross objects with \code{mqmscan} and the single-QTL
mapping function \code{scanone} (for reference).  The effect of increasing the
amount of missing data on QTL mapping, using default values, can been seen in Figure~\ref{augment6}.


<<augment5>>=
mqm5 <- mqmscan(maug5)
mqm10 <- mqmscan(maug10)
mqm80 <- mqmscan(maug80)
@ 

<<augment5b>>=
msim5 <- calc.genoprob(msim5)
one5 <- scanone(msim5)
msim10 <- calc.genoprob(msim10)
one10 <- scanone(msim10)
msim80 <- calc.genoprob(msim80)
one80 <- scanone(msim80)
@

<<augment6,eval=FALSE,echo=FALSE>>=
op <- par(mfrow=c(2,2))
plot(mqm5,mqm10,mqm80,col=c("green","blue","black"),main="MQM missing data")
legend("topleft",c("MQM 5%","MQM 10%","MQM 80%"),col=c("green","blue","black"),lwd=1)
plot(one5,mqm5,main="5% missing", col=c("red", "green"))
legend("topleft",c("scanone","MQM"),col=c("red","green"),lwd=1)
plot(one10,mqm10,main="10% missing", col=c("red", "blue"))
legend("topleft",c("scanone","MQM"),col=c("red","blue"),lwd=1)
plot(one80,mqm80,main="80% missing", col=c("red", "black"))
legend("topleft",c("scanone","MQM"),col=c("red","black"),lwd=1)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<augment6>>
@
\caption{\Atintro. Effect of missing data on \code{mqmscan} (green=5\%, blue=10\%, black=80\%) and \code{scanone} (red) methods
\label{augment6}}
\end{figure}
\clearpage

\section{Multiple QTL Model (MQM) mapping}

\label{QTL modelling}

The \code{multitrait} dataset, distributed with R/qtl, contains 24 metabolite
traits from a RIL population of \At \cite{Keurentjes2006} (see also section
\ref{multitrait} and \code{help(multitrait)} in R).  

Here we analyse the \code{multitrait} dataset using both \code{scanone} (single-\qtl\ analysis) and \code{mqmscan} (multiple \QTL\ model mapping).  First
augment the data using the \code{mqmaugment} function with \code{minprob=1.0} (see also
section \ref{augmentation}). 

\intro{Use \code{scanone} and \code{mqmscan} after filling missing data with
\code{mqmaugment minprob=1.0}}

<<>>=
data(multitrait)
maug <- mqmaugment(multitrait,minprob=1.0)
mqm_co0 <- mqmscan(maug)
@

We compare \code{mqmscan} with \code{scanone}, for which
one first calculates conditional QTL genotype probabilities via
\code{calc.genoprob}.

<<>>=
multitrait <- calc.genoprob(multitrait, step=5)
m_one <- scanone(multitrait)
@

Figure~\ref{AtNoCofs} shows that, with default parameters, the results from 
\mqm\ are similar to \code{scanone}. There are, however, 
differences between the two methods, which will become clear in the next part.

\begin{figure}
<<NoCofsMulti,fig=TRUE,echo=FALSE,height=3>>=
plot(mqm_co0, m_one, col=c("black", "green"), lty=1:2)
@ 
\caption{\Atintrocolors. 
\mqm\ shows similar results as single \qtl\ mapping, 
when used without \emph{augmentation} (\code{minprob} is 1.0), and with default parameters
\label{AtNoCofs}}
\end{figure}

By default \MQM\ introduces ``pseudomarkers'' at fixed intervals.
A pseudomarker has a name like \code{c7.loc25}, which is the
pseudomarker at 25 \cM\ on chromosome 7. (Note that this reflects the standard naming
used in R/qtl.)
Each
chromosome is divided into `fictional markers' spaced equally \code{step.size}
\cM\ apart. A LOD score for underlying QTL is calculated at these 
pseudomarkers. A small \code{step.size} allows for smoother profiles compared
with a pure marker-based mapping approach. The real markers are listed between
the pseudomarkers. In the result you can remove the pseudomarkers by using
the function \code{mqmextractmarkers}, as follows:

<<>>=
real_markers <- mqmextractmarkers(mqm_co0)
@ 


For model selection in \mqm, we first need to supply the
algorithm with an initial model.  This initial model can be produced in two
ways: by (1) building a model by hand (forward stepwise), or (2) by unsupervised
backward elimination on a large number of markers (discussed in Section~\ref{backelim}).

Here we first build this initial model by hand using a forward
stepwise approach. (Note that the automated procedure is preferred, both for
theoretical and practical reasons.) A model consists of a set of markers we
want to account for. We can start building the initial model by adding
cofactors at markers with high LOD scores scored by using \code{mqmscan} with
default values. Figure~\ref{AtNoCofs} displayed a large QTL peak on chromosome 5
at 35 \cM. So we account for that by setting a cofactor at the marker
nearest to the peak on chromosome 5 and running \code{mqmscan} again.  (See
Figures~\ref{Cofactor4} and \ref{Cofactor4b}.)

\intro{Add marker GH.117C (chromosome 5, at 35 \cM) as a cofactor}

<<>>=
max(mqm_co0)
find.marker(maug,chr=5,pos=35)
multitoset <- find.markerindex(maug,"GH.117C")
setcofactors <- mqmsetcofactors(maug,cofactors=multitoset)
mqm_co1 <- mqmscan(maug, setcofactors)
@

The function \code{find.marker} identifies the name of the marker
closest to 35 \cM.  The function \code{find.markerindex} translates the
marker name into a cofactor number.  The function \code{mqmsetcofactors}
sets up a cofactor list for use with \code{mqmscan}.  

\intro{Plot the results of the genome scan after adding a single cofactor (Figure~\ref{Cofactor4})}

%<<Cofactor4,eval=FALSE>>=
%par(mfrow = c(2,1))
%plot(mqmgetmodel(mqm_co1))
%plot(mqm_co1)
%@ 

% \begin{figure}
% <<fig=TRUE,echo=FALSE>>=
% # plot after adding first cofactor
% <<Cofactor4>>
% @
% \caption{\hyperintro. A cofactor is added at chromosome 4 (D4Mit164) and kept in the
% model. The LOD score (evidence) for a second QTL on chromosome 1 increases (see also
% Figure \ref{Cofactor4b})\label{Cofactor4}} 
% \end{figure}

% --------------
<<Cofactor4multi,eval=FALSE>>=
par(mfrow = c(2,1))
plot(mqmgetmodel(mqm_co1))
plot(mqm_co1)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
# plot after adding first cofactor
<<Cofactor4multi>>
@
\caption{\Atintro. \code{mqmscan} after a cofactor is added at the top scoring marker of chromosome 5. During the analysis it is kept in the
model \label{Cofactor4}} 
\end{figure}


% --------------

\intro{Plot the \code{mqmscan} results with \code{scanone} results as follows (Figure~\ref{Cofactor4b})}

%<<Cofactor4b,eval=FALSE>>=
%plot(mqm_co1, m_one, col=c("black","green"), lty=1:2)
%@

% \begin{figure}
% <<fig=TRUE,echo=FALSE,height=3>>=
% <<Cofactor4b>>
% @
% \caption{\hyperintrocolors, after introducing a
% cofactor at chromosome 4 (D4Mit164) accounting for variation explained at that
% location\label{Cofactor4b}}
% \end{figure}


% -------------------------

<<Cofactor4bMULTI,eval=FALSE>>=
plot(mqm_co1, m_one, col=c("black","green"), lty=1:2)
@

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3>>=
<<Cofactor4bMULTI>>
@
\caption{\Atintro\ after introducing a cofactor on chromosome 5 (GH.117C). 
\code{mqmscan} (black) differs from \code{scanone} (green, dashed) \label{Cofactor4b}}
\end{figure}

% ---------------------------

Figures~\ref{Cofactor4} and \ref{Cofactor4b} show the effect of setting a single marker as a
cofactor related to the \qtl\ on chromosome 5, followed by an \mqm\ scan.  The
marker is not dropped and it passes initial thresholding to account for
the \code{cofactor.significance} level. LOD scores are expected to change slightly,
because of variation already explained by the \qtl\ on
chromosome 5. This can be made visisble by plotting these new
results against the \mqm\ \qtl\ mapping without cofactors (Figure~\ref{Cofactor4b}).

Figure~\ref{Cofactor4b} shows the second peak on chromosome 4 at 10
\cM\ increases. Add that to the model and check if the model with both
cofactors changes the \qtl. Combining \code{find.markerindex} with \code{find.marker},
adds the new cofactor to the cofactor already in \code{multitoset} (see Figure~\ref{twowaycomparison}): 

<<>>=
# summary(mqm_co1)
multitoset <- c(multitoset,find.markerindex(maug,find.marker(maug,4,10)))
setcofactors <- mqmsetcofactors(maug,cofactors=multitoset)
mqm_co2 <- mqmscan(maug, setcofactors)
@
% -----------

\intro{Plot after adding second cofactor on chromosome 4 at 10 \cM}

<<twowaycomparison,eval=FALSE>>=
par(mfrow = c(2,1))
plot(mqmgetmodel(mqm_co2))
plot(mqm_co2, mqm_co1, col=c("black","green"), lty=1:2)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<twowaycomparison>>
@
\caption{\Atintro\ using one cofactor (on chromosome 5) versus two cofactors (on
chromosome 4 and 5). After introducing a second cofactor on chromosomes 4 there
appears to be only a small difference in the likelihood scores for each
chromosome. (\code{mqmscan} 2 cofactor (black) differs from \code{mqmscan} 1 cofactors (green, dashed))
For this trait we could add more cofactors (Figure~\ref{threewaycomparison})
However this does not improve the current two QTL model\label{twowaycomparison}}
\end{figure}

% ---------------------------




\intro{Plot the results with 0, 1 and 2 cofactors as follows}

<<threewaycomparisonmulti,eval=FALSE>>=
plot(mqm_co0, mqm_co1, mqm_co2,
     col=c("black","red","blue"), lty=1:3)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3>>=
# plot closeup of threeway comparison
<<threewaycomparisonmulti>>
@
\caption{\Atintro. Comparison of \mqm\ results after QTL mapping using 0, 1 and 2 
cofactor(s) at the start of backward elimination.  (\code{mqmscan} 2 cofactor (blue) 
differs from \code{mqmscan} 1 cofactors (red) and \code{mqmscan} with only no cofactors (black) \label{threewaycomparison}}
\end{figure}
% ---------------------



When using the function \code{mqmsetcofactors}, or the automated function \code{mqmautocofactor} discussed below, the
number of cofactors is compared against the number of individuals inside the
cross object. If there is a danger of setting too many cofactors the two
cofactor functions will display an error about 
setting more cofactors than the sample size permits and not return a
cofactor list.

\mqm\ verifies the \code{cofactor.significance} level specified by the
user. Here the marker on chromosome 1 was informative enough and included into the model.
This way a new initial model consisting of cofactors on chromosome 4 and
5 was created. This (forward) selection of cofactors can continue until there are no more
informative markers. 

Manually determining which marker to set a cofactor can be very time consuming
in the case of many \qtl\ underlying a trait. It is also prone to overfitting.
Furthermore, manual fitting is
generally not feasible for a large number of traits. Fortunately \mqm\ provides
unsupervised backward elimination, which is described in the next section.

\clearpage

\section{Unsupervised cofactor selection through backward elimination\label{backelim}}


\mqm\ provides unsupervised backward elimination on a large number of markers
by selecting cofactors automatically. Normally the number of markers in a
dataset is much larger than the number of individuals. \mqm\ allows using as many
cofactors simultaneously as the number of individuals minus 12\cite{jansen07}.

The functions: "\code{mqmsetcofactor}" and "\code{mqmautocofactors}" both
create lists of cofactors that can be used for backward elimination.
\code{mqmautocofactor} accounts for the underlying marker density and is
therefore suitable for datasets with few individuals.  See
Figure~\ref{ManualAuto} for a comparison on the multitrait dataset, using the
\code{mqmsetcofactors} function to set cofactors every 5th marker and
\code{mqmautocofactor} to set 50 cofactors across the genome. After cofactor
selection \mqm\ analyses and drops the least informative cofactor from the
model. This step is repeated until a limited number of informative cofactors
remain.  When taking marker density into account, an extra cofactor is
introduced on chromosome 1 (see Figure~\ref{ManualAuto}).

% ---- PJOTR is here

After unsupervised backward elimination \code{mqmscan} scans each chromosome
using the model with the retained cofactors. For example, after setting 50
cofactors using \code{mqmautocofactor} and \code{mqmsetcofactors} map \qtl\ for
the various traits in \code{multitrait}, which contains 24 metabolite traits
from a RIL population of \At\, as described in section \ref{multitrait}. The
\qtl\ LOD scores differ between \mqm\ and single \qtl\ mapping with
\code{scanone} (see Figures~\ref{Backward1} and \ref{Backward2}).

\intro{Unsupervised cofactor selection through backward elimination} 

<<eval=FALSE>>=
autocofactors <- mqmautocofactors(maug,50)
mqm_auto <- mqmscan(maug, autocofactors)
setcofactors <- mqmsetcofactors(maug,5)
mqm_backw <- mqmscan(maug, setcofactors)
@

<<echo=FALSE>>=
autocofactors <- mqmautocofactors(maug,50)
mqm_auto <- mqmscan(maug, autocofactors)
setcofactors <- mqmsetcofactors(maug,5)
mqm_backw <- mqmscan(maug, setcofactors)
@

\intro{Visual inspection of the initial models}

<<ManualAutoStart,eval=FALSE>>=
par(mfrow = c(2,1))
plotcofactors(maug,autocofactors)
plotcofactors(maug,setcofactors)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
# plot result of cofactor selection
<<ManualAutoStart>>
@
\caption{\Atintro. \code{mqmsetcofactor} after introducing cofactors at every fifth marker (top) and
\code{mqmautocofactor} automatic marker selection (bottom). Automatic selection takes the underlying
marker density into consideration.
\label{ManualAutoStart}}
\end{figure}

\intro{Plot the results as follows}

<<ManualAuto,eval=FALSE>>=
par(mfrow = c(2,1))
plot(mqmgetmodel(mqm_backw))
plot(mqmgetmodel(mqm_auto))
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
# plot result of cofactor backward elimination
<<ManualAuto>>
@
\caption{\Atintro\ after introducing cofactors at every fifth marker (top) and
Automatic marker selection (bottom). We see that using \code{mqmautocofactor}
does place a cofactor at chromosome 1 (see Figure \ref{ManualAutoStart}), while
this one is missed by mqmsetcofactors (AFTER backward elimination this extra
marker remains significant) \label{ManualAuto}} \end{figure}

<<Backward1multi,eval=FALSE>>=
par(mfrow = c(2,1))
plot(mqmgetmodel(mqm_backw))
plot(mqm_backw)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
# plot result of cofactor backward elimination
<<Backward1multi>>
@
\caption{backward elimination on \At after introducing cofactors at every fifth
marker and backward elimination. We see the above the markers that were found
significant for trait X3.Hydroxypropyl after backward elimination. Below in
black the profile is shown across the genome. We see that the variation in
trait X3.Hydroxypropyl maps to chromosome 4 and 5\label{Backward1}}
\end{figure}

The \code{mqmgetmodel} function returns the final model from the output of
\code{mqmscan}.  This model can be further investigated using the \code{fitqtl}
and \code{fitqtl} routines from R/qtl.NOTE: that \code{mqmgetmodel} can only be
used after backward elimination that produces a significant model. The
resulting model can also be used to obtain the location and name of the
significant cofactors.

\intro{Plot result of MQM backward elimination against that of \code{scanone}}

We plot the results along with those from \code{scanone} as follows:
<<Backward2,eval=FALSE>>=
plot(mqm_backw, m_one, col=c("black","green"), lty=1:2)
@ 

% ------------------------------
<<Backward2multi,eval=FALSE>>=
plot(mqm_backw, m_one, col=c("black","green"), lty=1:2)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3>>=
<<Backward2multi>>
@
\caption{\Atintro. Backward elimination using \code{mqmscan} with multiple cofactors (black) compared to \code{scanone} (in red) \label{Backward2}}
\end{figure}

% -------------------------------

\mqm\ \qtl\ mapping may result in many significant markers, with multiple hits
on each chromosome. Figure~\ref{Backward2} shows that at
\code{cofactor.significance=0.02} chromosomes 4 and 5 are involved.  Lowering
the significance level from 0.02 to 0.002 may yield a smaller model.  In
biology extensive models are sometimes preferred, but in general a simpler
model is more easily understood and, perhaps, validated. Decreasing the
significance level also has the advantage that we can be more sure of the \qtl
we report. In our example we already found a small model so we don't expect to
loose the two QTL on chromosome 4 and chromosome 5. And indeed when deceasing
the \code{cofactor.significance} no additional cofactors are dropped from the
model (See Figure~\ref{lowalpha})

% <<FigLowAlpha,eval=FALSE>>=
% result <- mqmscan(hyperaug, cofactorlist, cofactor.significance=0.002)
% par(mfrow = c(2,1))
% plot(mqmgetmodel(result))
% plot(result)
% @ 
\clearpage
\intro{Plot with lowered \code{cofactor.significance}}

% \begin{figure}
% <<fig=TRUE,echo=FALSE>>=
% <<FigLowAlpha>>
% @
% \caption{\hyperintro, initially with cofactors at every fifth marker; after backwards elimination (\code{cofactor.significance = 0.002}).}
% \end{figure}



%-----------------------

<<FigLowAlpha,eval=FALSE>>=
multiresult <- mqmscan(maug, setcofactors, cofactor.significance=0.002)
par(mfrow = c(2,1))
plot(mqmgetmodel(multiresult))
plot(multiresult)
@ 
\clearpage
\intro{\Atintro. Scan done when using a lower \code{cofactor.significance} but using the same strating markers as Figure~\ref{Backward1}\label{lowalpha}}

\begin{figure}
<<fig=TRUE,echo=FALSE>>=
<<FigLowAlpha>>
@
\caption{\Atintro. With a lower cofactor.significance we get no change 
in the model (the QTL are still significant). However based on the 
trait under examination and our samplesize, increasing cofactor.significance 
could reduce the number of significant QTL in our model  \label{FigLowAlpha}}
\end{figure}

%-----------------------

When comparing the \mqm\ scan in Figure~\ref{FigLowAlpha} with the original
\code{scanone} result in Figure~\ref{AtNoCofs} there are some notable
differences.  Some \qtl\ show higher significance (LOD scores) and some others
show lower significance and are, therefore, estimated to be less likely
involved in this trait.

Figures can be reconstructed from the result of \code{mqmscan} using the
\code{mqmplot.singletrait} function (see, for example,
Figure~\ref{AutoCofactor}). Here the model and \qtl\ profile are retrieved.
These functions can only be used with \code{mqmscan}, as they require the
additional information about the inferred \qtl\ model.  The results also
contain the \emph{estimated} information content per marker.  

<<AutoCofactor,eval=FALSE>>=
mqmplot.singletrait(result, extended=TRUE)
@ 

% \begin{figure}
% <<fig=TRUE>>=
% <<AutoCofactor>>
% @
% \caption{\hyperintro, initially with cofactors at every fifth marker; after backward elimination (\code{cofactor.significance = 0.002}). \code{mqmplot.singletrait} function
% shows retained information in \code{result} with added weighting of information at
% marker positions\label{AutoCofactor}}
% \end{figure}

<<AutoCofactor,eval=FALSE>>=
mqmplot.singletrait(multiresult, extended=TRUE)
@ 

\begin{figure}
<<fig=TRUE>>=
<<AutoCofactor>>
@
\caption{\Atintro\ showing the results of trait 1 when using with multiple
cofactors, visualized using \code{mqmplot.singletrait}.  This plotting routine
give some more information compared to \code{plot.scanone}. In red the
information content per marker is shown, and in black the QTL score, the blue
line is created by multiplying the red line with the black line. Thus
compensating QTLscores for the amount of information at a certain genetic
location.  \label{AutoCofactor}} \end{figure}

The second column \code{info} in the result is calculated from the deviation of
the \emph{ideal} marker distribution. For example, with a dataset of 100 \At,
when comparing two distinct phenotypes at a marker location, we have most power
when both groups are equally divided into 50 \At, and virtually no power when
we have one mouse versus a group of 99 \At. We can multiply the estimated \qtl\
effect by this information content to `clean' the QTL profile by giving less
weight to less informative markers. Please note that the sample size already
plays a role in calculating \qtl. Meanwhile it allows (informal) further
weighting/exploring \emph{information} content (Figure~\ref{AutoCofactor}).

\section{MQM effect plots}

The function \code{mqmplot.directedqtl} may be used to plot LOD curves with an
indication of the sign of the estimated QTL effects.  This requires that
\code{mqmscan} was run with \code{outputmarkers=TRUE}, but that is the default.
For an example on creating directed QTL plots see Figure~\ref{QTLeffects}:
% <<QTLeffects,eval=FALSE>>=
% dirresults <- mqmplot.directedqtl(hyperaug,result)
% @ 

% The output is in Figure \ref{QTLeffects}.

% \begin{figure}
% <<fig=TRUE,echo=FALSE,height=3.5>>=
% <<QTLeffects>>
% @
% \caption{Same as Figure \ref{AutoCofactor}, but with LOD scores
%   multiplied by $\pm$1, according to the sign of the estimated QTL effect.\label{QTLeffects}}
% \end{figure}

<<QTLeffects,eval=FALSE>>=
dirresults <- mqmplot.directedqtl(maug,multiresult)
@ 

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3.5>>=
<<QTLeffects>>
@
\caption{Same as Figure~\ref{AutoCofactor}, but with LOD scores
multiplied by $\pm$1, according to the sign of the estimated QTL effect.\label{QTLeffects}}
\end{figure}

The results in Figure~\ref{FigLowAlpha} implied that QTL on chromosomes 4 and 5 are
associated with the metabolite X3.Hydroxypropyl. If we want to investigate the effects
of the QTL, we can use the functions \code{plot.pxg} and \code{effectplot}.
The following plots show these for markers GH.117C (main effect,
Figure~\ref{MainEffectsD1}) and the interaction between GH.117C and
GA1 (Figure~\ref{epistatic1}). 

% <<MainEffectsD1,eval=FALSE>>=
% plot.pxg(hyperaug,marker="D1Mit102")
% @ 

% \begin{figure}
% <<fig=TRUE, echo=FALSE,height=3>>=
% <<MainEffectsD1>>
% @
% \caption{\hyperintro. Show effect of marker D1Mit102 using \code{plot.pgx}\label{MainEffectsD1}}
% \end{figure}

%----------------------------------------------

<<MainEffectsD1,echo=FALSE,eval=FALSE>>=
plot.pxg(multitrait,marker="GH.117C")
@ 

\begin{figure}
<<fig=TRUE, echo=FALSE,height=3>>=
<<MainEffectsD1>>
@
\caption{\Atintro, shown in this plot are the main effect of marker GH.117C on
trait X3.Hydroxypropyl using \code{plot.pgx}.  We see the two possible
genotypes at this marker and with the traitvalues for each individual plotted
per category. The blue line is the mean of the AA group the red line the mean
of the BB genotype group \label{MainEffectsD1}} \end{figure}

%----------------------------------------------

The initial scans for X3.Hydroxypropyl in Figure~\ref{Backward1} possibly show
two main efect \qtl\ on chromosome 4 and 5.  We can investigate possible
interactions between these main effect QTL using the \code{effectplot}
function. To investigate the possible interaction we select markers GA1
(significant in Figure~\ref{Backward1} and Figure~\ref{Backward2}) and GH.117C
(significant in Figure~\ref{Backward2} and \ref{AutoCofactor}). See
Figure~\ref{epistatic1}.

% <<epistatic1,eval=FALSE>>=
% effectplot(hyperaug, mname1="D1Mit19", mname2="D1Mit102")
% @ 

% \begin{figure}
% <<fig=TRUE,echo=FALSE,height=3.5>>=
% <<epistatic1>>
% @
% \caption{\hyperintro. \code{effectplot} shows possible small epistatic effects between
% markers D1Mit19 and D1Mit102\label{epistatic1}}
% \end{figure}

%-----------------------------------------------

<<epistatic1,eval=FALSE>>=
effectplot(multitrait, mname1="GH.117C", mname2="GA1")
@

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3.5>>=
<<epistatic1>>
@
\caption{\Atintro. \code{effectplot} shows possible epistatic interaction
between markers GH.117C and GA1. We can see this because the genotype of GA1
seems to obscure the effect of GH.117C. An individual that has BB at GA1 has no
difference in expression between being AA or BB at GH.117C. However when an
individual is AA at GA1 there is clear difference between the two genotype
means (~1.500 BB versus 12000 when AA) at GH.117C \label{epistatic1}}
\end{figure}

%------------------------------------------------


Likewise, in case we are interested in the interactions between the first small
hump on chromosomes 1 (marker: PVV4 not significant) and the main efect on 5
(GH.117C), we could make interaction plots between these two markers with a
high LOD score on those chromosomes.  See Figure~\ref{epistatic2}.
% <<epistatic2,eval=FALSE>>=
% effectplot(hyperaug, mname1="D1Mit102", mname2="D5Mit213")
% @ 
% Figure \ref{epistatic2} shows little evidence for an interaction between
% the two markers D1Mit102 and D5Mit213, as the lines are close to parallel. 
% 
% \begin{figure}
% <<fig=TRUE,echo=FALSE,height=3.5>>=
% <<epistatic2>>
% @
% \caption{\hyperintro. \code{effectplot} shows little evidence for an
%   epistatic interaction between markers D1Mit102 and D5Mit213\label{epistatic2}}
% \end{figure}

%------------------------------------------------

<<epistatic2,eval=FALSE>>=
effectplot(multitrait, mname1="PVV4", mname2="GH.117C")
@ 
Figure~\ref{epistatic2} shows no evidence for an interaction between
the two markers D1Mit102 and D5Mit213, as the lines are close to parallel. 

\begin{figure}
<<fig=TRUE,echo=FALSE,height=3.5>>=
<<epistatic2>>
@
\caption{\Atintro. \code{effectplot} shows no epistatic effects between
markers GH.117C and PVV4, ths can be seen because the two lines run parallel, 
the genotype on one location (PVV4) does not affect the effect of the expression 
on GH.117C other location \label{epistatic2}}
\end{figure}
 
%------------------------------------------------ 

\clearpage

\section{QTL significance} 

\label{significance}

To estimate significance of \qtl\ (and perhaps further exclude markers from a
model) permutation testing is provided by the function \code{mqmpermutation}. This step
is computationally expensive\footnote{In the tutorial, for all examples, 25
permutations are used. A real experiment should use over 1000 permutation tests.}
as the same test is repeated many times on shuffled data. Each test calculates
LOD scores for non associated (randomly ordered) data. 

\mqm\ provides parametric and non-parametric bootstrapping to estimate QTL
significance. The \code{bootmethod} parameter of the \code{mqmpermutation} function selects
the type.  If you have access to multiple CPUs on your computer you can use the
SNOW package \cite{tierney03,tierney04}, which allows parallel
computations on multiple CPU/cores. The snowpackage is available on cran, using Rgui 
it can be installed by selecting from the menu, Packages and choosing Install 
Package(s) from the dropdown menu. Select a cran mirror near your own location 
for fast download and then select the SNOW package. It will start downloading the package, 
and install any dependencies needed. Linux users can download a copy of SNOW from 
\url{http://cran.r-project.org/web/packages/snow/index.html}. Once the package 
has finished downloading the tar.gz file can be installed using R CMD INSTALL snow.tar.gz

\intro{Calculate significance - using SNOW parallelization parameters}
<<>>=
require(snow)
results <- mqmpermutation(maug,scanfunction=mqmscan,cofactors=setcofactors,n.cluster=2,n.perm=25,batchsize=25)
@
\begin{figure}
<<fig=TRUE>>=
mqmplot.permutations(results)
@
\caption{\Atintro. To calculate \qtl\ significance permutation is used, randomly distributing trait values 
amongst individuals (25 times) gives an indication what LOD scores are found by chance. Here \qtl\ with
a \lod\ higher than 2.5 LOD score can be considered significant (at
\code{cofactor.significance=0.05} (green) or \code{cofactor.significance=0.10} (blue)).
Estimation from permuting a single trait (X3.Hydroxypropyl). Chromosomes are signified by
the gray grid lines.}
\end{figure}

<<>>=

resultsrqtl <- mqmprocesspermutation(results)
summary(resultsrqtl)
@

For small datasets, with a limited amount of classical traits, \code{mqmpermutation}
works fine. To summarize these results, mqmprocespermutation makes the output 
comparable to scanone when using n.perm parameter for permutation. 
However for large genome wide association studies (GWAS) use \code{mqmscanfdr}
instead, which estimates false discovery rates (FDR) across the entire dataset
at \lod\ cutoff. The routines have similar parameters.

To estimate FDR, whole genome information is permuted with \code{mqmscanfdr}. This
method takes correlation between traits into account and gives an unbiased
estimate of FDR at different (user specified) thresholds. The function scans
the traits and counts observed \qtl\ (markers with a LOD above \code{x}) when
setting a certain threshold. It permutes all the data leaving the correlation
structure between traits intact. For this small example very high FDR estimates
are calculated because of the small amount of permutations and the high
correlation between traits. We thus discover many QTL that map to the same
location, this could normally only happen when we have an information sparse
marker, or correlated traits, often seen in microarray experiments.

\intro{Calculate FDR}
<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
mqmscanfdr(multifilled,mqmscanall,cofactors=setcofactors,n.cluster=2)
@

The function \code{mqmpermutation} does single trait permutations, and does not take
correlation between the traits into account. The advantage is that a confidence
interval is provided for each significant QTL.  The \mqm\ output needs to be
converted to the standard R/qtl format using the \code{mqmprocesspermutation}
function. The resulting object is of class \code{scanoneperm} and can be used by the
standard R/qtl functions for further analysis. 

Finally, with regard to parallelized processing using the multiple cores,
nowadays even standard in laptop computers, we can assign, for example four
cores using a batch size of 10. This way each core gets 10 traits to calculate
QTL profiles on.  When QTL modeling and mapping is done for these 10 traits.
Another 10 traits are send to the core, until all traits have been analyzed.
Using larger batches is efficient as for every batch the full R environment is
started and initialized.


\section{Parallelized xQTL analysis}

MQM can analyse, so called, xQTL traits simultaneously using parallel computing
on multiple CPU/cores, and even computer clusters. xQTL datasets (expression
eQTL, metabolite mQTL) usually contain a large amount of phenotypes with known
locations on the genome. These locations can be used for detecting cis/trans
regulation, for example. For QTL mapping every phenotype requires one or more
calls to \code{mqmscan}. In addition special plots are presented for xQTL studies.

As an example, the mQTL dataset \code{multitrait},
an \At\ RIL cross, contains 24 metabolites measured (phenotypes).
Of these 24 phenotypes we will only scan the first 5 phenotypes by setting 
the \code{pheno.col} parameter. To map back the 
regulatory locations of these metabolites one can use plain scanning of
all metabolites (initially without cofactors). Next, we plot all the profiles
in a heatmap (see Figure~\ref{At.heatmap1}). In this heatmap the colors represent the LOD score, on
the x-axis the marker number and on the y-axis the metabolite. The traits
are numbered in the plot. Plot heatmap without cofactors and then the
heatmap with cofactors and backward elimination. Figure~\ref{At.heatmap2} shows
improvement over Figure~\ref{At.heatmap1} because of an improved signal to noise ratio.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
resall <- mqmscan(multifilled,pheno.col=c(1,2,3,4,5),n.cluster=2)
@
\begin{figure}
<<fig=TRUE>>=
mqmplot.multitrait(resall,type="image")
@
\caption{\Atintro. Heatmap of metabolite expression traits, with profiles created using \mqm\ without preselected cofactors. The colors represent the LOD score, on
the x-axis the marker number and on the y-axis the metabolite\label{At.heatmap1}}
\end{figure}


<<>>=
cofactorlist <- mqmsetcofactors(multifilled,3)
resall <- mqmscan(multifilled,pheno.col=c(1,2,3,4,5),cofactors=cofactorlist,n.cluster=2)
@
\begin{figure}
<<fig=TRUE>>=
mqmplot.multitrait(resall,type="image")
@
\caption{\Atintro. Heatmap of metabolite expression traits, with profiles created using \mqm\ with cofactors at each third marker. The colors represent the LOD
score, on the x-axis the marker number and on the y-axis the metabolite\label{At.heatmap2}}
\end{figure}

Use \code{mqmplot.multitrait} for more graphical output. (Unfortunately this does not
show in the generated PDF, but in R it shows the trait profiles)

<<>>=
mqmplot.multitrait(resall,type="lines")
@

% \begin{figure}
% <<fig=TRUE>>=
% mqmplot.multitrait(resall,type="lines")
% @
% \caption{Results of scanning 25 traits using \mqm\ cofactors at each third marker}
% \end{figure}

The next plot is the \code{mqmplot.circle}. It shows a circular
representation of the genome. After using automatic backward selection
certain markers are found to be significant using \mqm. When highlighting, the
size of the markers is scaled, based on the LOD score of the marker for the
highlighted trait. There are a number of options that can be specified. The main parameters are:
\code{highlight}: Highlighting a specific trait, and calculating interactions between the 
significant cofactors. All other traits are grayed out, but remain partly visible, in this 
way it is possible to see if significant QTL for this trait are also colocating with other traits
\code{interactstrength}: When highlighting a specific trait interactions between significant markers 
are calculated, However the are only drawn (and reported in the output) if the effect change is larger 
then \code{interactstrength} * the summed standard deviation. \code{spacing} Spacing between the chromosomes in Cm.


\begin{figure}
<<fig=TRUE>>=
mqmplot.circle(multifilled, resall)
@
\caption{Circleplot 1 - Multiple traits without locations, traits are in the centre 
connected by a colored spline to their QTL locations. The significant QTL locations 
are depicted as solid square circles at the side of the plot (lower number are closer 
to the centre). Here a 'hotspot' of QTLs is visible on chromosome 5 \label{circle1}}
\end{figure}

\begin{figure}
<<fig=TRUE>>=
mqmplot.circle(multifilled, resall, highlight=2)
@
\caption{Circleplot 2 - Multiple traits without locations with a highlight on trait 2. The significant QTL locations 
are depicted as solid red square circles at the side of the plot. The different lines shown here signify epistatic 
interactions (see Figure~\ref{epistatic1}). In this plot the blue lines are locations which are modulating eachothers 
expression (higher or lower), the green lines show a flip in effect. Imagina a situation with two markers, having AA at 
marker 1 shows trait mean AA > trait mean BB at marker2 however when the individual has BB at marker 1 the effect at marker 2 is reversed AA < BB. \label{circle2}}
\end{figure}

The next plot is \code{mqmplot.cistrans}. This plot is only available
when genomic locations of the traits are known, typically in xQTL studies. By
default the R/qtl cross object does not store this data. So the user has to add
this information to the cross object using the addloctocross function. After
this operation the cis.trans plot can be created for \qtl\ with associated
genome locations. For example with expression QTL (eQTL) usually the probes on
the microarray have a known chromosomal location.  

The two axis of the cistrans plot both show the genetic location. The x-axis
is, normally, the \qtl\ location and the y-axis the locations of the trait
(e.g. a the microarray probe).

\begin{figure}
<<fig=TRUE>>=
data(locations)
multiloc <- addloctocross(multifilled, locations)
mqmplot.cistrans(resall, multiloc, 5, FALSE, TRUE)
@
\caption{\Atintro. mqmplot.cistrans, available when \qtl\
have associated genome locations. \qtl\ are plotted against the position on the
genome they were measured (here mQTL for \At), cutoff is at a lod score of 5}
\end{figure}

When having locations we can, again, use the \code{mqmplot.circle} function, now with 
the extra information.

\begin{figure}
<<fig=TRUE>>=
mqmplot.circle(multiloc,resall, highlight=2)
@
\caption{\Atintro. Circleplot 3 - Multiple traits with locations added, again we highlight trait number 2, 
the difference between this plot and the previous circle plot \ref{circle2} is that an extra red triangle 
showing the genetic location of the trait under consideration. These kind of plots are only possible if 
location information is added to the \code{cross} object \label{circle3}}
\end{figure}

\clearpage

\section{Overview of all \mqm\ functions}
\begin{table}[ht]
	\caption{Added functionality}
	\centering
	\begin{tabular}{| l | c | }
	\hline
	mqmaugment:& mqm data augmentation \\
	mqmscan:& mqm modeling and scanning \\
	mqmsetcofactors:& Set cofactors at these markers (or every x marker) \\
	find.markerindex:& Change markernumbering into mqmformat \\
	mqmscanall:& mqmscanall to scan all traits using mqm\\
	mqmpermutation:& Single trait permutation \\
	mqmscanfdr:& Genome wide False Discovery Rates \\	
	mqmprocesspermutation:& Creates an R/qtl permutationobject \\
                & from the output of the \code{mqmpermutation} function \\
	mqmplot.multitrait:& plotting of multiple traits (MQMmulti object) \\
	mqmplot.nice:& plotting of mutiple traits (MQMmulti object) \\
  mqmplot.directedqtl:& Plotting of signle trait with added qtl effect\\
	mqmplot.permutations:& plot methode to show single trait permutations \\
	mqmplot.singletrait:& plotting of single trait analysis with information content \\
	mqmplot.circle:& Genome plot of QTL in a circle (optional: Use of location information)\\  
	mqmplot.cistrans:& Genomewide plot of cis- and transQTL above a threshold \\
  addloctocross:& Adding genetic locations for traits \\	
	mqmtestnormal:& Tests the normallity of a trait \\ 	
	\hline
	\end{tabular}
	\label{tbl:tabel1}
\end{table}

\clearpage

\NOTE{the bibliography should use standard bibtex}

\begin{thebibliography}{9}
	\bibitem{broman09}
		Broman, K.W.; 2009.
		\emph{A brief tour of R/qtl}
		http://www.rqtl.org, R/qtl tutorials.
  \bibitem{rqtlbook}
    Karl W. Broman and Saunak Sen.	  	  
	  \emph{A Guide to QTL Mapping with R/qtl}
    Springer, 2009
	\bibitem{broman03}
		Broman, K.W.; Wu, H.; Sen, S.; Churchill, G.A.; 2003.
		\emph{R/qtl: QTL mapping in experimental crosses}
		Bioinformatics, 19:889--890.
	\bibitem{jansen07}
		Jansen R. C.; 2007.
		\emph{Chapter 18 - Quantitative trait loci in inbred lines} 
		Handbook of Stat. Genetics 3th edition,(c) 2007 John Wiley \& Sons, Ltd.
	\bibitem{tierney04}	
		Tierney, L.; Rossini, A.; Li, N.; and Sevcikova, H.; 2004.
		\emph{The snow Package: Simple Network of Workstations} Version 0.2-1. 
	\bibitem{tierney03}
		Rossini, A.; Tierney, L.; and Li, N.; 2003.
		\emph{Simple parallel statistical computing}
		R. UW Biostatistics working paper series University of Washington. 193
	\bibitem{jansen01}	
		Jansen R. C.; Nap J.P.; 2001
		\emph{Genetical genomics: the added value from segregation}
		Trends in Genetics, 17, 388--391.
	\bibitem{jansen94}		
		Jansen R. C.; Stam P.; 1994
		\emph{High resolution of quantitative traits into multiple loci via interval mapping}
		Genetics, 136, 1447--1455. 
  \bibitem{jansen94b}
	  Jansen R.C.
		\emph{Controlling the Type I and Type II Errors in Mapping Quantitative Trait Loci}.
    Genetics, Vol 138, 871--881
	\bibitem{Churchill94}
		Churchill, G. A.; and Doerge, R. W.; 1994
		\emph{Empirical threshold values for quantitative trait mapping}
		Genetics 138, 963--971. 
	\bibitem{jansen93}
		Jansen R. C.; 1993
		\emph{Interval mapping of multiple quantitative trait loci}
		Genetics, 135, 205--211.
	\bibitem{Dempster77}
		Dempster, A. P.; Laird, N. M. and Rubin, D. B.; 1977 
		\emph{Maximum likelihood from incomplete data via the EM algorithm}
		J. Roy. Statist. Soc. B, 39, 1--38.
  \bibitem{CIMa}
         Zeng, Z. B.; 1993 \emph{Theoretical basis for separation of
           multiple linked gene effects in mapping quantitative trait
           loci} Proc. Natl. Acad. Sci. USA, 90, 10972--10976.
  \bibitem{CIMb}
         Zeng, Z. B.; 1994 \emph{Precision mapping of quantitative
           trait loci.}
         Genetics, 136, 1457--1468
  \bibitem{sugiyama}
    Sugiyama, F.; Churchill, G.A.; Higgins, D.C.; Johns, C.;
    Makaritsis, K.P.; Gavras, H.; Paigen, B.; 2001. \emph{Concordance
      of murine quantitative trait loci for salt-induced hypertension
      with rat and human loci} Genomics, 71, 70--77. 
  \bibitem{Keurentjes2006}
Keurentjes, J. J. and Fu, J. and de Vos, C. H. and Lommen, A. and Hall, R. D. and Bino, R. J. and van der Plas, L. H. and Jansen, R. C. and Vreugdenhil, D. and Koornneef, M.
     (2006), \emph{The genetics of plant metabolism.} Nature Genetics.
     38-7, 842--849
  \bibitem{Koornneef1998}
Alonso-Blanco, C. and Peeters, A. J. and Koornneef, M. and Lister, C. and Dean, C. and van den Bosch, N. and Pot, J. and Kuiper, M. T.; 1998
     \emph{
Development of an AFLP based linkage map of Ler, Col and Cvi
     Arabidopsis thaliana ecotypes and construction of a Ler/Cvi recombinant
     inbred line population}. Plant J. 14(2), 259--271.

\end{thebibliography}
\end{document}
