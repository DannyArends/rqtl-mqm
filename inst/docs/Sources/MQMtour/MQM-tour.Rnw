\documentclass[11pt]{article}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{23.5cm}
\setlength{\textwidth}{17.0cm}
\setlength{\oddsidemargin}{.025in}
\setlength{\evensidemargin}{.025in}
\setlength{\textwidth}{6.25in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{float}
\usepackage{Sweave}
\usepackage{url}

\newcommand{\mqm}{\emph{MQM}}
\newcommand{\MQM}{\mqm}
\newcommand{\qtl}{QTL}
\newcommand{\QTL}{\qtl}
\newcommand{\lod}{LOD}
\newcommand{\cM}{cM}
\newcommand{\rqtl}{\emph{R/qtl}}
\newcommand{\cim}{\emph{CIM}}
\newcommand{\At}{\emph{Arabidopsis thaliana}}
\newcommand{\FIXME}{({\bf FIXME!})}
\newcommand{\CHECK}{({\bf CHECK!})}
\newcommand{\NOTE}{({\tt NOTE: })}
\newcommand{\intro}[1]{\vspace{0.2in}\emph{#1:}}
\newcommand{\code}{\texttt}

\newcommand{\hyperintro}{\qtl\ profiles of the hyper dataset with the trait bp (blood
pressure) in an experiment with 250 mice using \mqm}
\newcommand{\hyperintrocolors}{ \qtl\ profiles of the hyper dataset with the trait bp (blood pressure) in an experiment with 250 mice comparing \mqm\ (black) and
single \qtl\ mapping with \code{scanone} (green)}
\newcommand{\Atintro}{\At\ RIL mQTL dataset with 24 metabolites as phenotypes}

\title { Tutorial - Multiple QTL Model (MQM) Analysis }
\author { Danny Arends, Pjotr Prins, Karl Broman and Ritsert Jansen }
\begin {document}
\maketitle
\clearpage

\section{Introduction}

\input{mqm/description.txt}

\vspace{0.3in}

\input{mqm/advantages.txt}

\input{mqm/limitations.txt}

Despite these limitations, \mqm\footnote{Note that \mqm\
  \cite{jansen94} is \emph{not the
same} as composite interval mapping (CIM)\cite{CIMa,CIMb}, though
both methods were introduced around the same time. The great advantage of MQM compared to interval mapping in reducing the chance of a type I error
(a QTL is indicated at a location where there is no QTL
present) and in reducing the chance of a type II error (a QTL is
not detected)\cite{jansen94b}} is a valuable addition to
the \qtl\ mapper's toolbox. It is able to deal with interference of \qtl,
{\color{red} \textbf{[I'm not sure you mean by ``interference of qtl'']}}
handles missing data and allows more precise detection than other methods. This
tutorial will show how to use \mqm\ for \qtl\ mapping. Also R/qtl's \mqm\ is
faster than other implementations and scales on multi-CPU systems and computer
clusters.

\mqm\ is an integral part of the free \rqtl\
package\cite{rqtlbook,broman09,broman03} for the R statistical
language\footnote{We assume the reader knows how to load his data into R using
the R/qtl \code{read.cross} function, see also the R/qtl tutorials\cite{broman09}
and book\cite{rqtlbook}}. 

\section{A quick overview of \mqm}

These are the typical steps in an \mqm\ \qtl\ analysis

\begin{itemize}
\item Load an experiment using R/qtl data types
\item Fill in missing data, using either \code{fill.geno} or \code{mqmaugmentdata}
\item Unsupervised backward elimination to analyse \emph{cofactors}, using \code{mqmscan}
\item Optionally select \emph{cofactors\/} at markers that are thought to influence \qtl\ at, or near, the location
\item Permutation or simulation analysis to get estimates of significance, using \code{mqmpermute}
\end{itemize}

Using maximum likelihood (ML), or restricted maximum likelihood (REML), the
algorithm employs a backward elimination strategy to identify \qtl\ underlying
the trait. The algorithm passes through the following stages:

\begin{itemize}
\item Calculation of relative marker positions and detection of linkage groups
\item Optional (Re-)estimation of genetic map and/or recombination frequencies
\item Likelihood estimations of the full model using all cofactors
\item Backward elimination of cofactors, followed by a
      genome scan for \qtl
\item If there are no \emph{cofactors\/} defined, perform a
      genome scan testing each genetic location independently
\end{itemize}

The interval map created during the genome scan and the \qtl\ model are
returned as an (\mqm\ extended) R/qtl \code{scanone} object. Several special
plotting routines are available for \mqm\ results.

\section{Data augmentation}
\label{augmentation}

Most real world datasets are incomplete. That is, genotype information is
missing, or can have multiple plausible values. \mqm\ automatically expands the
dataset by adding all potential variants and attaches a probability.  For
example, information is missing (unknown) at a marker location for one
individual. Based on the values of the neighbouring markers, and the
(estimated) recombination rate, a probability is attached.  With \mqm\ all
likely options are considered.  When genotypes A and B are possible at the
location two `individuals' are created in the augmentation step, one with
genotype A, and one with genotype B. A probability is attached to either
variant. The combined probabilities of all markers tells us whether a
combination of variants is likely, or not.

To see an example of missing data with an F2 intercross, we can
visualize the genotypes of the individuals using \code{plot.geno} In figure
\ref{missing data} there are 2\% missing values in white. The other
colors are genotypes at a certain position, for a certain
individual. Simulate an F2 dataset with 2\% missing markers as
follows:

\intro{Simulate a dataset with missing data}
% set seed so that everything comes out exactly the same
<<setseed,echo=FALSE>>= 
set.seed(19696527)
@ 
<<>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.02)
@
\begin{figure}[ht]
<<fig=TRUE>>=
geno.image(mycross)
@
\caption{Simulate an F2 cross with 2\% missing data starting from the
map10 F2 intercross. The figure displays genotypes of 100 individuals 
with around 2\% missing data (white) for the map10 F2 intercross}
\label{missing data}
\end{figure}

Before we can go to the next step (\qtl\ genome scan), the data has to be
completed (i.e. no more missing data).  There are two possibilities: either use
the imputation function \code{fill.geno} or use the \mqm\ data augmentation routine
\code{mqmaugment}.  With \code{fill.geno} a single `most likely' genotype is filled in using
multiple imputations, estimating the missing marker genotypes. In contrast,
\emph{augmentation} introduces multiple likely genotypes. At this stage
\code{mqmaugment} is specific to \mqm\ and the recommended procedure\footnote{Note
that after augmentation the resulting cross object is no longer suitable for
the use with \code{scanone} or \cim, because of the additional information stored}.

In this tutorial we use \mqm's augmentation. The function \code{mqmaugment} fills in
missing genotypes for us. For each missing genotype data, at a marker, it fills
in all possible genotypes and calculates the probability. When the total
probability is more likely than the \code{minprob} parameter the \emph{augmented}
individual is stored in the new cross object, ready for QTL mapping.

The important parameters are: \code{cross}, \code{pheno.col}, \code{maxaugind}, \code{minprob} and
\code{verbose} (see also the \code{mqmaugment} help page in R). \code{maxaugind} sets the
maximum number of \emph{augmented} genotypes per individual in a dataset. The
default of 82 allows six missing markers per individual in a BC, and four in an
F2. As a result the user has to increase the
\code{maxaugind} parameter when there are more missing markers. 

The \code{minprob} parameter sets the minimum probability of a genotype for
inclusion in the augmented dataset. This genotype probability is calculated for
every marker \emph{relative} to the most likely individual.
Note that setting this value too
low may result in dropping individuals entirely as \code{maxaugind} is quickly
reached footnote{The current version drops individuals that go beyond
\code{maxaugind}.  This is undesirable behaviour and will be fixed in an upcoming
release. A value \code{minprob=1.0} may prevent the dropping of individuals, making
augmentation behave similar to \code{fill.geno}'s imputation method}.  Use the verbose
option to get more feedback on the augmentation routine and check how many
individuals are dropped. So first we try augmentation with \code{minprob=1.0} (figure \ref{augment1}):

\intro{Plot augmented data using \code{plot.geno} with \code{minprob=1.0}}
<<>>=
# displays warning because MQM ignores the X chromosome in an F2
augmentedcross <- mqmaugment(mycross, minprob=1.0)
@
\begin{figure}[ht]
<<fig=TRUE>>=
plot.geno(augmentedcross)
@
\caption{\code{plot.geno} displays the genotypes of 100 filled individuals
(\code{mqmaugment} with \code{minprob=1} means only the `most likely' individual is
used and
no real expansion of the dataset takes place, similar to \code{fill.geno})}
\label{augment1}
\end{figure}

With a lower \code{minprob}, more \emph{likely} genotypes considered, and the
resulting \emph{augmented} dataset will be larger. The (weighted) augmented
individuals with all possible genotypes theoretically leads to more accurate
mapping when dealing with missing values \cite{jansen93}\footnote{Note that
the augmented dataset can only be used with \mqm\ functions.  \mqm\ functions
recognise expanded individuals as single entities.  Other R/qtl functions, like
\code{scanone}, assume the augmented individuals are \emph{real} individuals}.
Try augmentation with \code{minprob=0.1} (figure \ref{augment2}):

\begin{figure}[ht]
<<fig=TRUE>>=
augmentedcross <- mqmaugment(mycross, minprob=0.1)
plot.geno(augmentedcross)
@
\caption{\code{plot.geno} displays the \emph{augmented} genotypes of 100 individuals. There are a total of 340 `expanded' individuals in this plot, because \mqm\ 
fills in missing markers with all likely genotypes (an average expansion of 3.4 per
individual)}
\label{augment2}
\end{figure}

\clearpage

\section{MQM multiple QTL model mapping}

\label{QTL modelling}

The famous mouse hypertension dataset, which comes standard with
R/qtl, is a backcrossed (BC) offspring of mice with two listed traits:
bloodpressure (bp) and sex. Here we show an example of running both \code{scanone}
single marker \qtl\ analysis and \code{mqmscan} multiple \QTL\ model mapping, to map
\qtl\ for blood pressure. First, \emph{complete} missing data:

% \texttt{qtl.mqm} help page into a \LaTeX{} document

\intro{Use \code{scanone} and \code{mqmscan} after filling missing data with \code{mqmaugment}}
<<>>=
data(hyper)
colors <- c("Black","Green")
lines <- c(2,1)
hyperaug <- mqmaugment(hyper, minprob=1.0)
result_scanone <- scanone(hyper)
result_no_cofactors <- mqmscan(hyperaug)
@

After loading \code{data(hyper)} we create a dataset without missing genotypes using
the \code{mqmaugment} routine discussed in section \ref{augmentation}.  Next we scan
for \qtl\ using both \code{scanone} and \code{mqm} routines (using default parameters).
Figure \ref{NoCofs} shows that with \code{minprob=1.0} there is virtually no
difference in outcome.

\begin{figure}[p]
<<fig=TRUE>>=
# plot scanone/mqm comparison
plot(result_no_cofactors, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors. Both routines
are virtually equal when used without \emph{augmentation} and no extra parameters}
\label{NoCofs}
\end{figure}

MQM introduces pseudo markers by default (unlike \code{scanone}). A pseudo
marker has a name like c7.loc25 - i.e. the 25 \cM\ pseudo marker on chromosome 7. This reflects the internally used interval mapping. The chromosomes are divided into
equally spaced sections. Therefore each chromosome is divided into fictional
markers spaced equally \code{stepsize} \cM\ apart. A LOD score for underlying QTLs
is calculated at these fictional pseudo markers. A small \code{stepsize} allows for
smoother profiles compared with pure marker based mapping approaches. The real
markers are listed between the pseudo markers. In the result you can remove the
pseudo markers by using the function \code{mqmextractmarkers(res)}.

For (automatic) model selection in \mqm\ we first need to supply the
algorithm with an initial model.  This initial model can be produced in two
ways: by (1) building a model by hand (forward stepwise), or (2) by unsupervised
backward elimination on a large number of markers. 

First we will demonstrate building the initial model by hand using a forward
stepwise approach (note that the automated procedure is preferred, both for
theoretical and practical reasons). A model consists of a set of markers we
want to account for. We can start building the initial model by adding cofactors
at markers with high LOD scores. figure \ref{NoCofs} displayed a large QTL peek
on chromosome 4 at 30 \cM, so let us account for that by setting a cofactor at
the marker nearest to the peek on chromosome 4 and perform a new \mqm\ scan
(result in figures \ref{Cofactor4} and \ref{Cofactor4b}):

\intro{Add marker D4Mit164 as a cofactor}
<<>>=
#Summary results shows the highest lodscores per chromosome
summary(result_no_cofactors)
#find.marker extracts the marker nearest to chr4 at 30cM
find.marker(hyperaug,chr=4,pos=30)
#which.marker translates the name into a cofactor number
toset <- which.marker(hyperaug,"D4Mit164")
cofactorlist <- mqmcofactors(hyperaug,toset)
#scan again
result_1 <- mqmscan(hyperaug, cofactorlist)
@

\intro{Plot after adding cofactor}
\begin{figure}[ht]
<<fig=TRUE>>=
# plot after adding first cofactor
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_1))
plot(result_1)
@
\caption{\hyperintro. A cofactor is added at chromosome 4 (D4Mit164) and kept in the
model. The LOD score (evidence) for a second QTL on chromosome 1 increases (see also
figure \ref{Cofactor4b})
} 
\label{Cofactor4}
\end{figure}

Figures \ref{Cofactor4} and \ref{Cofactor4b} show the effect of setting a single marker as a
cofactor related to the \qtl\ on chromosome 4, followed by an \mqm\ scan.  The
marker is not dropped and it passes initial thresholding to account for
the \code{cofactor.significance} level. LOD scores are expected to change (slightly)
genome wide because of variation already explained by the \qtl\ on
chromosome 4. This can be shown by plotting these new
results against the \mqm\ \qtl\ mapping without cofactors (figure \ref{Cofactor4b}).

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result_1, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactor at chromosome 4 (D4Mit164) accounting for variation explained at that
location}
\label{Cofactor4b}
\end{figure}

Figure \ref{Cofactor4b} clearly shows the second peek on chromosome 1 at 70
\cM\ increases, so we add that to the model and check if the model with both
cofactors changes the \qtl. Again, combining \code{which.marker} with \code{find.marker},
adds the new cofactornumber \code{c} with the cofactor already in \code{toset} (see figure 
\ref{twowaycomparison}): 

\intro{Add another cofactor on chromosome 1 at 70 \cM}
<<>>=
# summary(result_1)
toset <- c(toset,which.marker(hyperaug,find.marker(hyperaug,1,70)))
cofactorlist <- mqmcofactors(hyperaug,toset)
result_2 <- mqmscan(hyperaug, cofactorlist)
@

\intro{Plot after adding second cofactor}
\begin{figure}[ht]
<<fig=TRUE>>=
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_2))
plot(result_2, result_1, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactors at chromosomes 1 and 4 there appears only a small difference in the likelihood 
scores for each chromosome. The LOD scores do not appear to improve much after adding 
the second cofactor on chromosome 4. But\ldots (see figure \ref{threewaycomparison}) }
\label{twowaycomparison}
\end{figure}


\begin{figure}[ht]
<<fig=TRUE>>=
# plot closeup of threeway comparison
plot(result_no_cofactors, result_1, result_2,chr=c(1,11,15),col=c("black","red","blue"),lwd=c(3,2,1))
@
\caption{Three way comparison of the last scans. We see here a closeup of chromosome 1
scanned using \mqm\ with 3 different cofactor settings: no cofactors (black), 
a single cofactor on chromosome 4 (Red) and cofactors on chromosome 1 and 4.(Blue) 
The LOD scores on chromosome 1 increase with more cofactors, while the peaks on
the chromosome 11 and 15 decrease}
\label{threewaycomparison}
\end{figure}

When using the functions \code{mqmcofactors} and \code{mqmsetcofactors}, the
number of cofactors is compared against the number of individuals inside the
cross object. If there is a danger of setting too many cofactors the two
cofactor functions will warn the user by displaying an error about the user
trying to set more cofactors than \code{samplesize} permits, and not return a
cofactorlist.

\mqm\ verifies the \code{cofactor.significance} level specified by the user. The
marker on chromosome 1 is informative enough to be included into the model.
Thus creating a new initial model consisting of cofactors on chromosome 4 and
1. This (forward) selection of cofactors can continue until there are no more
informative markers. 

Manually determining which marker to set a cofactor can be very time consuming
in the case of many QTL underlying a trait. It is also prone to overfitting
(because the user manipulates the data). Furthermore manual fitting is
generally not feasable for a large number of traits. Fortunately \mqm\ provides
unsupervised backward elimination.

\clearpage

\section{Unsupervised backward elimination}

% "setting cofactors every other marker" HUH? Waarom zou je dit willen doen?
% Is dit de standaard proc? Raar. Moet toch afhangen van het aantal
% individuen en van de locaties van de merkers????????

\mqm\ provides unsupervised backward elimination on a large number of markers by 
setting cofactors beforehand. When \code{samplesize} allows it a 
a cofactor is set at every marker. However, normally only a subset of 
locations is of interest. The \code{cofactor} function creates
a list consisting of multiple cofactors. Iteratively the algorithm analyses all the
markers and drops the least informative from the model. This step is repeated
until a limited number of significant cofactors is left.

After backward elimination \mqm\ scans each chromosome using the model that
includes the retained cofactors. Here we set a cofactor at every fifth
marker using \code{mqmsetcofactors}, and assess which chromosomes may be implicated in
high bloodpressure (results in figures \ref{Backward1} and \ref{Backward2}):

\intro{Automatic cofactor selection through backward elimination}
<<>>=
cofactorlist <- mqmsetcofactors(hyperaug,5)
result <- mqmscan(hyperaug, cofactorlist, plot=T)
@
\begin{figure}[ht]
<<fig=TRUE>>=
# plot result of cofactor backward elimination
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, after introducing cofactors at every fifth marker and
backward elimination}
\label{Backward1}
\end{figure}
<<>>=
mqmgetmodel(result)
@

The \code{mqmgetmodel} function returns the final model from the resulting \code{scanone} type
object.  This model can be used with the \code{scantwo} routine from R/qtl. \code{mqmgetmodel}
can only be used after backward elimination as it requires a list of
cofactors. The resulting model can also be used to obtain the location and
name of the significant cofactors.

\clearpage
\intro{Plot result of MQM backward elimination against that of \code{scanone}}
\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors with cofactors at every fifth
marker for \mqm\, followed by backward elimination
(\code{cofactor.significance = 0.02})}
\label{Backward2}
\end{figure}

\mqm\ \qtl\ mapping may result in many significant markers, with multiple 
hits on each chromosome. Figure \ref{Backward2} shows that at 
\code{cofactor.significance=0.02} chromosomes 1,2,4,5,6 and 15(?) are involved. 
Lowering the significance level from 0.02 to 0.002 may yield a smaller model. 
In biology extensive models are sometimes preferred, but in general a simpler 
model is more easily understood and, perhaps, validated. Increasing 
this significance level (hopefully) has the advantage 
that we can be more sure of the \qtl. 

\intro{Plot with lowered \code{cofactor.significance}}
\begin{figure}[ht]
<<fig=TRUE>>=
result <- mqmscan(hyperaug, cofactorlist, cofactor.significance=0.002)
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backwards elimination (\code{cofactor.significance = 0.002}).
}
\label{FigLowAlpha}
\end{figure}
\clearpage

When comparing the \mqm\ scan in figure \ref{FigLowAlpha} with the original
\code{scanone} result in figure \ref{NoCofs} there are some notable differences.
Some \qtl\ show higher significance (LOD scores) and some others show lower
significance and are, therefore, estimated to be less likely involved in this
trait.

Figures can be reconstructed from the result (\code{scanone} object) using the
\code{mqmplot\_one} function (see, for example, figure \ref{AutoCofactor}). Here the
model and \qtl\ profile are retrieved.  These functions can only be used with
\code{mqmcan}, as they have an additional column \code{mqm} which contains the \qtl\
model.  This extra column/list also contains the \emph{estimated} information
content per marker.  

The column \code{mqm} is calculated from the deviation of the \emph{ideal} marker
distribution. For example, with a dataset of 100 mice, when comparing two
distinct phenotypes at a marker location, we have most power when both groups
are equally divided into 50 mice, and, virtually, no power when we have one
mouse versus a group of 49 mice. We can multiply the estimated \qtl\ effect by
this information content to `clean' the QTL profile by giving less weight to
less informative markers. Please note that in the sample size already plays a
role in calculating \qtl. Meanwhile it allows (informal) further
weighting/exploring \emph{information} content (figure \ref{AutoCofactor}).

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_one(result, extended=TRUE)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backward elimination (\code{cofactor.significance = 0.002}). \code{mqmplot\_one} function
shows retained information in \code{result} with added weighting of information at
marker positions
}
\label{AutoCofactor}
\end{figure}

\section{MQM effect plots}

Effects can be add to plots using \code{mqmplot\_directedqtl}, which requires
setting \code{outputmarkers=TRUE} with \code{mqmscan} (default).  To remove plotting the
virtual markers introduced by \mqm\ use \code{mqmextractmarkers(result)}. The
plotting function adds the sign of the effect to the LOD score of the marker
and calls the standard R/qtl plotting functions. An example can be found in
figure \ref{QTLeffects}.

\begin{figure}[ht]
<<fig=TRUE>>=
dirresults <- mqmplot_directedqtl(hyperaug,result)
@
\caption{Same as figure \ref{AutoCofactor}, but with effect sign 
added to the QTL profile.
}
\label{QTLeffects}
\end{figure}

Earlier figure \ref{FigLowAlpha} implied that chromosomes 1, 2, 4 and 5 are
associated with high blood pressure. If we want to investigate the effect we
can use \rqtl's standard plotting tools to visualize \emph{main\/} and/or \emph{epistatic\/}
effects. The following plots show these for markers "D1Mit102" (main effect,
figure \ref{MainEffectsD1}) and the interaction between "D1Mit102" and
"D5Mit213" (figure \ref{epistatic1}). These markers are selected chosen for
significance, based on mathematical distributions used by \mqm\ (a better
method, based on permutations, is discussed in section \ref{significance}). 


\begin{figure}[ht]
<<fig=TRUE, results=hide>>=
plot.pxg(hyperaug,marker="D1Mit102")
@
\caption{\hyperintro. Show effect of marker D1Mit102 using \code{plot.pgx}}
\label{MainEffectsD1}
\end{figure}

The initial scans for high bloodpressure in figure \ref{Backward1}
possibly show two \qtl\ on chromosome 1. The dual humped shape 
might be explained by an interaction between two QTL. 
We 
can find out if there is an interaction on chromosome 
1 by using the \code{effectplot} function. To investigate the possible 
interaction we select markers "D1Mit19" (significant in figure \ref{Backward1}) 
and "D1Mit102" (significant in figure \ref{Backward2} and
\ref{AutoCofactor}). See figure \ref{epistatic1}.

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit19", mname2="D1Mit102")
@
\caption{\hyperintro. \code{effectplot} shows possible small epistatic effects between
markers D1Mit19 and D1Mit102
}
\label{epistatic1}
\end{figure}

Likewise, in case we are interested in the interactions between
chromosome 1 and 5, we could make interaction plots between the two
markers with a high LOD score on those chromosomes by using the effect
plot. See figure \ref{epistatic2}.

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit102", mname2="D5Mit213")
@
\caption{\hyperintro. \code{effectplot} shows an epistatic effect between markers D1Mit102 and D5Mit213}
\label{epistatic2}
\end{figure}

Figure \ref{epistatic1} shows some possible evidence for an interaction between
the two markers D1Mit102 and D5Mit213, as both lines are non parallel. The two
loci `x' and `y' influence the trait in a significant way (because they were
selected as cofactors by \mqm). If the effect shows two parallel lines the
effect of both loci would be independent of one another. I.e. there is no
significant interaction between x and y.  Interactions like these are prime
wetlab candidates, and, perhaps, tell us something about the biology behind the
\qtl.

\clearpage

\section{QTL significance} 

\label{significance}

To estimate significance of \qtl\ (and perhaps further exclude markers from a
model) permutation testing is provided by the function \code{mqmpermute}. This step
is computationally expensive\footnote{In the tutorial, for all examples, 25
permutations are used. A real experiment should use over 1000 permutation tests}
as the same test is repeated many times on shuffled data. Each test calculates
LOD scores for non associated (randomly ordered) data. 

\mqm\ provides parametric and non-parametric bootstrapping to estimate QTL
significance. The \code{bootmethod} parameter of the \code{mqmpermute} function selects
the type.  If you have access to multiple CPUs on your computer you can use the
SNOW package \cite{tierney03,tierney04}, which allows parallel
computations on multiple CPU/cores. The snowpackage is available on cran, using Rgui 
it can be installed by selecting from the menu, Packages and choosing Install 
Package(s) from the dropdown menu. Select a cran mirror near your own location 
for fast download and then select the SNOW package. It will start downloading the package, 
and install any dependencies needed. Linux users can download a copy of SNOW from 
\url{http://cran.r-project.org/web/packages/snow/index.html}. Once the package 
has finished downloading the tar.gz file can be installed using R CMD INSTALL snow.tar.gz

\intro{Calculate significance - using SNOW parallelization parameters}
<<>>=
require(snow)
results <- mqmpermute(hyperaug,cofactors=cofactorlist,n.clusters=2,n.run=25,b.size=25)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_permutations(results)
@
\caption{\hyperintro. Calculate significance permuting 25 times over \qtl\ with
a \lod\ higher than 2.5 LOD score can be considered significant (at
\code{cofactor.significance=0.05} (green) or \code{cofactor.significance=0.10} (blue)).
Estimation from permuting a single trait. Chromosomes are signified by
the gray grid lines.
}
\end{figure}

<<>>=
resultsrqtl <- mqmprocesspermutation(results)
summary(resultsrqtl)
@

For small datasets, with a limited amount of classical traits, \code{mqmpermute}
works fine. For large genome wide association studies (GWAS) use \code{mqmscanfdr}
instead, which estimates false discovery rates (FDR) across the entire dataset
at \lod\ cutoff. The routines have similar parameters.

To estimate FDR, whole genome information is permuted with \code{mqmscanfdr}. This
method takes correlation between traits into account and gives an unbiased
estimate of FDR at different (user specified) thresholds. The function scans
the traits and counts observed \qtl\ (markers with a LOD above \code{x}) when
setting a certain threshold. It permutes all the data leaving the correlation
structure between traits intact. For this small example very high FDR estimates
are calculated because of the small amount of permutations and the high
correlation between traits. We thus discover many QTLs that map to the same
location, this could normally only happen when we have an information sparse
marker, or correlated traits, often seen in microarray experiments.

\intro{Calculate FDR}
<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
mqmscanfdr(multifilled,mqmscanall,cofactors=cofactorlist,n.clusters=2)
@

The function \code{mqmpermute} does single trait permutations, and does not take
correlation between the traits into account. The advantage is that a confidence
interval is provided for each significant QTL.  The \mqm\ output needs to be
converted to the standard R/qtl format using the \code{mqmprocesspermutation}
function. The resulting object is of class \code{scanoneperm} and can be used by the
standard R/qtl functions for further analysis. 

Finally, with regard to parallelized processing using the multiple cores,
nowadays even standard in laptop computers, we can assign, for example four
cores using a batch size of 10. This way each core gets 10 traits to calculate
QTL profiles on.  When QTL modeling and mapping is done for these 10 traits.
Another 10 traits are send to the core, until all traits have been analyzed.
Using larger batches is efficient as for every batch the full R environment is
started and initialized.


\section{Parallelized xQTL analysis}

MQM can analyse, so called, xQTL traits simultaneously using parallel computing
on multiple CPU/cores, and even computer clusters. xQTL datasets (expression
eQTL, metabolite mQTL) usually contain a large amount of phenotypes with known
locations on the genome. These locations can be used for detecting cis/trans
regulation, for example. For QTL mapping every phenotype requires one or more
calls to \code{mqmscan}. In addition special plots are presented for xQTL studies.

As an example, the mQTL dataset \code{multitrait},
an \At\ RIL cross, contains 24 metabolites measured (phenotypes).
Of these 24 phenotypes we will only scan the first 5 phenotypes by setting 
the \code{pheno.col} parameter. To map back the 
regulatory locations of these metabolites one can use plain scanning of
all metabolites (initially without cofactors). Next, we plot all the profiles
in a heatmap (see figure \ref{At.heatmap1}). In this heatmap the colors represent the LOD score, on
the x-axis the marker number and on the y-axis the metabolite. The traits
are numbered in the plot. Plot heatmap without cofactors and then the
heatmap with cofactors and backward elimination. Figure \ref{At.heatmap2} shows
improvement over figure \ref{At.heatmap1} because of an improved signal to noise ratio.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
resall <- mqmscan(multifilled,pheno.col=c(1,2,3,4,5),n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{\Atintro. Heatmap of metabolite expression traits, with profiles created using \mqm\ without preselected cofactors. The colors represent the LOD score, on
the x-axis the marker number and on the y-axis the metabolite}
\label{At.heatmap1}
\end{figure}


<<>>=
cofactorlist <- mqmsetcofactors(multifilled,3)
resall <- mqmscan(multifilled,pheno.col=c(1,2,3,4,5),cofactors=cofactorlist,n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{\Atintro. Heatmap of metabolite expression traits, with profiles created using \mqm\ with cofactors at each third marker. The colors represent the LOD
score, on the x-axis the marker number and on the y-axis the metabolite}

\label{At.heatmap2}
\end{figure}

Use \code{mqmplot\_nice} for more graphical output. (Unfortunately this does not
show in the generated PDF, but in R it shows the trait profiles)

<<>>=
mqmplot_nice(resall,legendloc=1)
@

% \begin{figure}[ht]
% <<fig=TRUE>>=
% mqmplot_nice(resall,legendloc=1)
% @
% \caption{Results of scanning 25 traits using \mqm\ cofactors at each third marker}
% \end{figure}

The next plot is the \code{mqmplot\_circle}. It shows a circular
representation of the genome. After using automatic backward selection
certain markers are found to be significant using \mqm. When highlighting, the
size of the markers is scaled, based on the LOD score of the marker for the
highlighted trait. 
\FIXME Improve description of this plot
\FIXME Multiple traits show \qtl\ outside the chromosome
(solid colored squares)

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_circle(multifilled, resall)
@
\caption{Circleplot 1 - Multiple traits without locations, traits are in the centre 
connected by a colored spline to their QTL locations}
\end{figure}

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_circle(multifilled, resall, highlight=2)
@
\caption{Circleplot 2 - Multiple traits without locations with a highlight on trait 2}
\end{figure}

The next plot is \code{mqmplot\_cistrans}. This plot is only available
when genomic locations of the traits are known, typically in xQTL studies. By
default the R/qtl cross object does not store this data. So the user has to add
this information to the cross object using the addloctocross function. After
this operation the cis\_trans plot can be created for \qtl\ with associated
genome locations. For example with expression QTL (eQTL) usually the probes on
the microarray have a known chromosomal location.  

The two axis of the cistrans plot both show the genetic location. The x-axis
is, normally, the \qtl\ location and the y-axis the locations of the trait
(e.g. a the microarray probe).

\begin{figure}[ht]
<<fig=TRUE>>=
data(locations)
multiloc <- addloctocross(multifilled,locations)
mqmplot_cistrans(resall, multiloc, 5, FALSE, TRUE)
@
\caption{\Atintro. mqmplot\_cistrans, available when \qtl\
have associated genome locations. \qtl\ are plotted against the position on the
genome they were measured (here mQTL for \At), cutoff is at a lod score of 5
}
\end{figure}

When having locations we can, again, use the \code{mqmplot\_circle} function, now with 
the extra information.

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_circle(multiloc,resall, highlight=2)
@
\caption{\Atintro. Circleplot 3 - Multiple traits with locations added, here we highlight trait number 2}
\end{figure}

\clearpage

\section{Overview of all \mqm\ functions}
\begin{table}[ht]
	\caption{Added functionality}
	\centering
	\begin{tabular}{| l | c | }
	\hline
	mqmaugment:& mqm data augmentation \\
	mqmscan:& mqm modeling and scanning \\
	mqmsetcofactors:& Set cofactors at these markers (or every x marker) \\
	which.marker:& Change markernumbering into mqmformat \\
	mqmscanall:& mqmscanall to scan all traits using mqm\\
	mqmpermute:& Single trait permutation \\
	mqmscanfdr:& Genome wide False Discovery Rates \\	
	mqmprocesspermutation:& Creates an R/qtl permutationobject \\
                & from the output of the \code{mqmpermute} function \\
	mqmplot\_multitrait:& plotting of multiple traits (MQMmulti object) \\
	mqmplot\_nice:& plotting of mutiple traits (MQMmulti object) \\
  mqmplot\_directedqtl:& Plotting of signle trait with added qtl effect\\
	mqmplot\_boot:& plot methode to show single trait permutations \\
	mqmplot\_one:& plotting of single trait analysis with information content \\
	mqmplot\_cistrans:& Genomewide plot of cis- and transQTLs above a threshold \\
  addloctocross:& Adding genetic locations for traits \\	
	mqmtestnormal:& Tests the normallity of a trait \\ 	
	\hline
	\end{tabular}
	\label{tbl:tabel1}
\end{table}

\clearpage

\NOTE: the bibliography should use standard bibtex

\begin{thebibliography}{9}
	\bibitem{broman09}
		Broman, K.W.; 2009.
		\emph{A brief tour of R/qtl}
		http://www.rqtl.org, R/qtl tutorials.
  \bibitem{rqtlbook}
    Karl W. Bromand and Saunak Sen.	  	  
	  \emph{A Guide to QTL Mapping with R/qtl}
    Springer, 2009
	\bibitem{broman03}
		Broman, K.W.; Wu, H.; Sen, S.; Churchill, G.A.; 2003.
		\emph{R/qtl: QTL mapping in experimental crosses}
		Bioinformatics, 19:889-890.
	\bibitem{jansen07}
		Jansen R. C.; 2007.
		\emph{Chapter 18 - Quantitative trait loci in inbred lines} 
		Handbook of Stat. Genetics 3th edition,(c) 2007 John Wiley \& Sons, Ltd.
	\bibitem{tierney04}	
		Tierney, L.; Rossini, A.; Li, N.; and Sevcikova, H.; 2004.
		\emph{The snow Package: Simple Network of Workstations} Version 0.2-1. 
	\bibitem{tierney03}
		Rossini, A.; Tierney, L.; and Li, N.; 2003.
		\emph{Simple parallel statistical computing}
		R. UW Biostatistics working paper series University of Washington. 193
	\bibitem{jansen01}	
		Jansen R. C.; Nap J.P.; 2001
		\emph{Genetical genomics: the added value from segregation}
		Trends in Genetics, 17, 388-391.
	\bibitem{jansen94}		
		Jansen R. C.; Stam P.; 1994
		\emph{High resolution of quantitative traits into multiple loci via interval mapping}
		Genetics, 136, 1447-1455. 
  \bibitem{jansen94b}
	  Jansen R.C.
		\emph{Controlling the Type I and Type II Errors in Mapping Quantitative Trait Loci}.
    Genetics, Vol 138, 871-881
	\bibitem{Churchill94}
		Churchill, G. A.; and Doerge, R. W.; 1994
		\emph{Empirical threshold values for quantitative trait mapping}
		Genetics 138, 963-971. 
	\bibitem{jansen93}
		Jansen R. C.; 1993
		\emph{Interval mapping of multiple quantitative trait loci}
		Genetics, 135, 205-211.
	\bibitem{Dempster77}
		Dempster, A. P.; Laird, N. M. and Rubin, D. B.; 1977 
		\emph{Maximum likelihood from incomplete data via the EM algorithm}
		J. Roy. Statist. Soc. B, 39, 1-38.
  \bibitem{CIMa}
         Zeng, Z. B.; 1993 \emph{Theoretical basis for separation of
           multiple linked gene effects in mapping quantitative trait
           loci} Proc. Natl. Acad. Sci. USA, 90, 10972-10976.
  \bibitem{CIMb}
         Zeng, Z. B.; 1994 \emph{Precision mapping of quantitative
           trait loci.}
         Genetics, 136, 1457-1468
         
\end{thebibliography}
\end{document}
